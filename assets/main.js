/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/images/address.svg":
/*!********************************!*\
  !*** ./src/images/address.svg ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/address.svg");

/***/ }),

/***/ "./src/images/banner.webp":
/*!********************************!*\
  !*** ./src/images/banner.webp ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/banner.webp");

/***/ }),

/***/ "./src/images/left-arrow.svg":
/*!***********************************!*\
  !*** ./src/images/left-arrow.svg ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/left-arrow.svg");

/***/ }),

/***/ "./src/images/luxurystore.jpeg":
/*!*************************************!*\
  !*** ./src/images/luxurystore.jpeg ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/luxurystore.jpeg");

/***/ }),

/***/ "./src/images/phone.svg":
/*!******************************!*\
  !*** ./src/images/phone.svg ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/phone.svg");

/***/ }),

/***/ "./src/images/right-arrow.svg":
/*!************************************!*\
  !*** ./src/images/right-arrow.svg ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/right-arrow.svg");

/***/ }),

/***/ "./src/images/slide.webp":
/*!*******************************!*\
  !*** ./src/images/slide.webp ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/slide.webp");

/***/ }),

/***/ "./src/images/time.svg":
/*!*****************************!*\
  !*** ./src/images/time.svg ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/time.svg");

/***/ }),

/***/ "./src/images/yext-favicon.png":
/*!*************************************!*\
  !*** ./src/images/yext-favicon.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/yext-favicon.png");

/***/ }),

/***/ "./src/images/yext-logo.svg":
/*!**********************************!*\
  !*** ./src/images/yext-logo.svg ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/yext-logo.svg");

/***/ }),

/***/ "./node_modules/flowbite/dist/flowbite.js":
/*!************************************************!*\
  !*** ./node_modules/flowbite/dist/flowbite.js ***!
  \************************************************/
/***/ (() => {

/******/
(function () {
  // webpackBootstrap

  /******/
  "use strict";

  var __webpack_exports__ = {}; // UNUSED EXPORTS: default

  ; // CONCATENATED MODULE: ./src/components/accordion.js

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var Default = {
    alwaysOpen: false,
    activeClasses: 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white',
    inactiveClasses: 'text-gray-500 dark:text-gray-400',
    onOpen: function onOpen() {},
    onClose: function onClose() {}
  };

  var Accordion = /*#__PURE__*/function () {
    function Accordion() {
      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Accordion);

      this._items = items;
      this._options = _objectSpread(_objectSpread({}, Default), options);

      this._init();
    }

    _createClass(Accordion, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._items.length) {
          // show accordion item based on click
          this._items.map(function (item) {
            if (item.active) {
              _this.open(item.id);
            }

            item.triggerEl.addEventListener('click', function () {
              _this.toggle(item.id);
            });
          });
        }
      }
    }, {
      key: "getItem",
      value: function getItem(id) {
        return this._items.filter(function (item) {
          return item.id === id;
        })[0];
      }
    }, {
      key: "open",
      value: function open(id) {
        var _this2 = this,
            _item$triggerEl$class,
            _item$triggerEl$class2;

        var item = this.getItem(id); // don't hide other accordions if always open

        if (!this._options.alwaysOpen) {
          this._items.map(function (i) {
            if (i !== item) {
              var _i$triggerEl$classLis, _i$triggerEl$classLis2;

              (_i$triggerEl$classLis = i.triggerEl.classList).remove.apply(_i$triggerEl$classLis, _toConsumableArray(_this2._options.activeClasses.split(" ")));

              (_i$triggerEl$classLis2 = i.triggerEl.classList).add.apply(_i$triggerEl$classLis2, _toConsumableArray(_this2._options.inactiveClasses.split(" ")));

              i.targetEl.classList.add('hidden');
              i.triggerEl.setAttribute('aria-expanded', false);
              i.active = false; // rotate icon if set

              if (i.iconEl) {
                i.iconEl.classList.remove('rotate-180');
              }
            }
          });
        } // show active item


        (_item$triggerEl$class = item.triggerEl.classList).add.apply(_item$triggerEl$class, _toConsumableArray(this._options.activeClasses.split(" ")));

        (_item$triggerEl$class2 = item.triggerEl.classList).remove.apply(_item$triggerEl$class2, _toConsumableArray(this._options.inactiveClasses.split(" ")));

        item.triggerEl.setAttribute('aria-expanded', true);
        item.targetEl.classList.remove('hidden');
        item.active = true; // rotate icon if set

        if (item.iconEl) {
          item.iconEl.classList.add('rotate-180');
        } // callback function


        this._options.onOpen(item);
      }
    }, {
      key: "toggle",
      value: function toggle(id) {
        var item = this.getItem(id);

        if (item.active) {
          this.close(id);
        } else {
          this.open(id);
        } // callback function


        this._options.onToggle(item);
      }
    }, {
      key: "close",
      value: function close(id) {
        var _item$triggerEl$class3, _item$triggerEl$class4;

        var item = this.getItem(id);

        (_item$triggerEl$class3 = item.triggerEl.classList).remove.apply(_item$triggerEl$class3, _toConsumableArray(this._options.activeClasses.split(" ")));

        (_item$triggerEl$class4 = item.triggerEl.classList).add.apply(_item$triggerEl$class4, _toConsumableArray(this._options.inactiveClasses.split(" ")));

        item.targetEl.classList.add('hidden');
        item.triggerEl.setAttribute('aria-expanded', false);
        item.active = false; // rotate icon if set

        if (item.iconEl) {
          item.iconEl.classList.remove('rotate-180');
        } // callback function


        this._options.onClose(item);
      }
    }]);

    return Accordion;
  }();

  window.Accordion = Accordion;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-accordion]').forEach(function (accordionEl) {
      var alwaysOpen = accordionEl.getAttribute('data-accordion');
      var activeClasses = accordionEl.getAttribute('data-active-classes');
      var inactiveClasses = accordionEl.getAttribute('data-inactive-classes');
      var items = [];
      accordionEl.querySelectorAll('[data-accordion-target]').forEach(function (el) {
        var item = {
          id: el.getAttribute('data-accordion-target'),
          triggerEl: el,
          targetEl: document.querySelector(el.getAttribute('data-accordion-target')),
          iconEl: el.querySelector('[data-accordion-icon]'),
          active: el.getAttribute('aria-expanded') === 'true' ? true : false
        };
        items.push(item);
      });
      new Accordion(items, {
        alwaysOpen: alwaysOpen === 'open' ? true : false,
        activeClasses: activeClasses ? activeClasses : Default.activeClasses,
        inactiveClasses: inactiveClasses ? inactiveClasses : Default.inactiveClasses
      });
    });
  });
  /* harmony default export */

  var accordion = Accordion;
  ; // CONCATENATED MODULE: ./src/components/collapse.js

  function collapse_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function collapse_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? collapse_ownKeys(Object(source), !0).forEach(function (key) {
        collapse_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : collapse_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function collapse_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function collapse_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function collapse_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function collapse_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) collapse_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) collapse_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var collapse_Default = {
    triggerEl: null,
    onCollapse: function onCollapse() {},
    onExpand: function onExpand() {},
    onToggle: function onToggle() {}
  };

  var Collapse = /*#__PURE__*/function () {
    function Collapse() {
      var targetEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var options = arguments.length > 1 ? arguments[1] : undefined;
      collapse_classCallCheck(this, Collapse);
      this._targetEl = targetEl;
      this._triggerEl = options ? options.triggerEl : collapse_Default.triggerEl;
      this._options = collapse_objectSpread(collapse_objectSpread({}, collapse_Default), options);
      this._visible = false;

      this._init();
    }

    collapse_createClass(Collapse, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._triggerEl) {
          if (this._triggerEl.hasAttribute('aria-expanded')) {
            this._visible = this._triggerEl.getAttribute('aria-expanded') === 'true' ? true : false;
          } else {
            // fix until v2 not to break previous single collapses which became dismiss
            this._visible = this._targetEl.classList.contains('hidden') ? false : true;
          }

          this._triggerEl.addEventListener('click', function () {
            _this._visible ? _this.collapse() : _this.expand();
          });
        }
      }
    }, {
      key: "collapse",
      value: function collapse() {
        this._targetEl.classList.add('hidden');

        if (this._triggerEl) {
          this._triggerEl.setAttribute('aria-expanded', 'false');
        }

        this._visible = false; // callback function

        this._options.onCollapse();
      }
    }, {
      key: "expand",
      value: function expand() {
        this._targetEl.classList.remove('hidden');

        if (this._triggerEl) {
          this._triggerEl.setAttribute('aria-expanded', 'true');
        }

        this._visible = true; // callback function

        this._options.onExpand();
      }
    }, {
      key: "toggle",
      value: function toggle() {
        if (this._visible) {
          this.collapse();
        } else {
          this.expand();
        }
      }
    }]);
    return Collapse;
  }();

  window.Collapse = Collapse;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-collapse-toggle]').forEach(function (triggerEl) {
      var targetEl = document.getElementById(triggerEl.getAttribute('data-collapse-toggle'));
      new Collapse(targetEl, {
        triggerEl: triggerEl
      });
    });
  });
  /* harmony default export */

  var collapse = Collapse;
  ; // CONCATENATED MODULE: ./src/components/carousel.js

  function carousel_toConsumableArray(arr) {
    return carousel_arrayWithoutHoles(arr) || carousel_iterableToArray(arr) || carousel_unsupportedIterableToArray(arr) || carousel_nonIterableSpread();
  }

  function carousel_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function carousel_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return carousel_arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return carousel_arrayLikeToArray(o, minLen);
  }

  function carousel_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function carousel_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return carousel_arrayLikeToArray(arr);
  }

  function carousel_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function carousel_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function carousel_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? carousel_ownKeys(Object(source), !0).forEach(function (key) {
        carousel_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : carousel_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function carousel_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function carousel_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function carousel_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function carousel_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) carousel_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) carousel_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var carousel_Default = {
    defaultPosition: 0,
    indicators: {
      items: [],
      activeClasses: 'bg-white dark:bg-gray-800',
      inactiveClasses: 'bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800'
    },
    interval: 3000,
    onNext: function onNext() {},
    onPrev: function onPrev() {},
    onChange: function onChange() {}
  };

  var Carousel = /*#__PURE__*/function () {
    function Carousel() {
      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      carousel_classCallCheck(this, Carousel);
      this._items = items;
      this._options = carousel_objectSpread(carousel_objectSpread(carousel_objectSpread({}, carousel_Default), options), {}, {
        indicators: carousel_objectSpread(carousel_objectSpread({}, carousel_Default.indicators), options.indicators)
      });
      this._activeItem = this.getItem(this._options.defaultPosition);
      this._indicators = this._options.indicators.items;
      this._interval = null;

      this._init();
    }
    /**
     * Initialise carousel and items based on active one
     */


    carousel_createClass(Carousel, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        this._items.map(function (item) {
          item.el.classList.add('absolute', 'inset-0', 'transition-all', 'transform');
        }); // if no active item is set then first position is default


        if (this._getActiveItem()) {
          this.slideTo(this._getActiveItem().position);
        } else {
          this.slideTo(0);
        }

        this._indicators.map(function (indicator, position) {
          indicator.el.addEventListener('click', function () {
            _this.slideTo(position);
          });
        });
      }
    }, {
      key: "getItem",
      value: function getItem(position) {
        return this._items[position];
      }
      /**
       * Slide to the element based on id
       * @param {*} position 
       */

    }, {
      key: "slideTo",
      value: function slideTo(position) {
        var nextItem = this._items[position];
        var rotationItems = {
          'left': nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
          'middle': nextItem,
          'right': nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
        };

        this._rotate(rotationItems);

        this._setActiveItem(nextItem.position);

        if (this._interval) {
          this.pause();
          this.cycle();
        }

        this._options.onChange();
      }
      /**
       * Based on the currently active item it will go to the next position
       */

    }, {
      key: "next",
      value: function next() {
        var activeItem = this._getActiveItem();

        var nextItem = null; // check if last item

        if (activeItem.position === this._items.length - 1) {
          nextItem = this._items[0];
        } else {
          nextItem = this._items[activeItem.position + 1];
        }

        this.slideTo(nextItem.position); // callback function

        this._options.onNext();
      }
      /**
       * Based on the currently active item it will go to the previous position
       */

    }, {
      key: "prev",
      value: function prev() {
        var activeItem = this._getActiveItem();

        var prevItem = null; // check if first item

        if (activeItem.position === 0) {
          prevItem = this._items[this._items.length - 1];
        } else {
          prevItem = this._items[activeItem.position - 1];
        }

        this.slideTo(prevItem.position); // callback function

        this._options.onPrev();
      }
      /**
       * This method applies the transform classes based on the left, middle, and right rotation carousel items
       * @param {*} rotationItems 
       */

    }, {
      key: "_rotate",
      value: function _rotate(rotationItems) {
        // reset
        this._items.map(function (item) {
          item.el.classList.add('hidden');
        }); // left item (previously active)


        rotationItems.left.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.left.el.classList.add('-translate-x-full', 'z-10'); // currently active item

        rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-10');
        rotationItems.middle.el.classList.add('translate-x-0', 'z-20'); // right item (upcoming active)

        rotationItems.right.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.right.el.classList.add('translate-x-full', 'z-10');
      }
      /**
       * Set an interval to cycle through the carousel items
       */

    }, {
      key: "cycle",
      value: function cycle() {
        var _this2 = this;

        this._interval = setInterval(function () {
          _this2.next();
        }, this._options.interval);
      }
      /**
       * Clears the cycling interval
       */

    }, {
      key: "pause",
      value: function pause() {
        clearInterval(this._interval);
      }
      /**
       * Get the currently active item
       */

    }, {
      key: "_getActiveItem",
      value: function _getActiveItem() {
        return this._activeItem;
      }
      /**
       * Set the currently active item and data attribute
       * @param {*} position 
       */

    }, {
      key: "_setActiveItem",
      value: function _setActiveItem(position) {
        var _this3 = this;

        this._activeItem = this._items[position]; // update the indicators if available

        if (this._indicators.length) {
          var _this$_indicators$pos, _this$_indicators$pos2;

          this._indicators.map(function (indicator) {
            var _indicator$el$classLi, _indicator$el$classLi2;

            indicator.el.setAttribute('aria-current', 'false');

            (_indicator$el$classLi = indicator.el.classList).remove.apply(_indicator$el$classLi, carousel_toConsumableArray(_this3._options.indicators.activeClasses.split(" ")));

            (_indicator$el$classLi2 = indicator.el.classList).add.apply(_indicator$el$classLi2, carousel_toConsumableArray(_this3._options.indicators.inactiveClasses.split(" ")));
          });

          (_this$_indicators$pos = this._indicators[position].el.classList).add.apply(_this$_indicators$pos, carousel_toConsumableArray(this._options.indicators.activeClasses.split(" ")));

          (_this$_indicators$pos2 = this._indicators[position].el.classList).remove.apply(_this$_indicators$pos2, carousel_toConsumableArray(this._options.indicators.inactiveClasses.split(" ")));

          this._indicators[position].el.setAttribute('aria-current', 'true');
        }
      }
    }]);
    return Carousel;
  }();

  window.Carousel = Carousel;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-carousel]').forEach(function (carouselEl) {
      var interval = carouselEl.getAttribute('data-carousel-interval');
      var slide = carouselEl.getAttribute('data-carousel') === 'slide' ? true : false;
      var items = [];
      var defaultPosition = 0;

      if (carouselEl.querySelectorAll('[data-carousel-item]').length) {
        carousel_toConsumableArray(carouselEl.querySelectorAll('[data-carousel-item]')).map(function (carouselItemEl, position) {
          items.push({
            position: position,
            el: carouselItemEl
          });

          if (carouselItemEl.getAttribute('data-carousel-item') === 'active') {
            defaultPosition = position;
          }
        });
      }

      var indicators = [];

      if (carouselEl.querySelectorAll('[data-carousel-slide-to]').length) {
        carousel_toConsumableArray(carouselEl.querySelectorAll('[data-carousel-slide-to]')).map(function (indicatorEl) {
          indicators.push({
            position: indicatorEl.getAttribute('data-carousel-slide-to'),
            el: indicatorEl
          });
        });
      }

      var carousel = new Carousel(items, {
        defaultPosition: defaultPosition,
        indicators: {
          items: indicators
        },
        interval: interval ? interval : carousel_Default.interval
      });

      if (slide) {
        carousel.cycle();
      } // check for controls


      var carouselNextEl = carouselEl.querySelector('[data-carousel-next]');
      var carouselPrevEl = carouselEl.querySelector('[data-carousel-prev]');

      if (carouselNextEl) {
        carouselNextEl.addEventListener('click', function () {
          carousel.next();
        });
      }

      if (carouselPrevEl) {
        carouselPrevEl.addEventListener('click', function () {
          carousel.prev();
        });
      }
    });
  });
  /* harmony default export */

  var carousel = Carousel;
  ; // CONCATENATED MODULE: ./src/components/dismiss.js

  function dismiss_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function dismiss_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? dismiss_ownKeys(Object(source), !0).forEach(function (key) {
        dismiss_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : dismiss_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function dismiss_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function dismiss_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function dismiss_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function dismiss_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) dismiss_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) dismiss_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var dismiss_Default = {
    triggerEl: null,
    transition: 'transition-opacity',
    duration: 300,
    timing: 'ease-out',
    onHide: function onHide() {}
  };

  var Dismiss = /*#__PURE__*/function () {
    function Dismiss() {
      var targetEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      dismiss_classCallCheck(this, Dismiss);
      this._targetEl = targetEl;
      this._triggerEl = options ? options.triggerEl : dismiss_Default.triggerEl;
      this._options = dismiss_objectSpread(dismiss_objectSpread({}, dismiss_Default), options);

      this._init();
    }

    dismiss_createClass(Dismiss, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._triggerEl) {
          this._triggerEl.addEventListener('click', function () {
            _this.hide();
          });
        }
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this2 = this;

        this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, 'opacity-0');

        setTimeout(function () {
          _this2._targetEl.classList.add('hidden');
        }, this._options.duration); // callback function

        this._options.onHide(this._targetEl);
      }
    }]);
    return Dismiss;
  }();

  window.Dismiss = Dismiss;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-dismiss-target]').forEach(function (triggerEl) {
      var targetEl = document.querySelector(triggerEl.getAttribute('data-dismiss-target'));
      new Dismiss(targetEl, {
        triggerEl: triggerEl
      });
    });
  });
  /* harmony default export */

  var dismiss = Dismiss;
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/math.js

  var math_max = Math.max;
  var math_min = Math.min;
  var round = Math.round;
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js

  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (isHTMLElement(element) && includeScale) {
      var offsetHeight = element.offsetHeight;
      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
      // Fallback to 1 in case both values are `0`

      if (offsetWidth > 0) {
        scaleX = round(rect.width) / offsetWidth || 1;
      }

      if (offsetHeight > 0) {
        scaleY = round(rect.height) / offsetHeight || 1;
      }
    }

    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  // Returns the layout rect of an element relative to its offsetParent. Layout
  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
    var isIE = navigator.userAgent.indexOf('Trident') !== -1;

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js

  var enums_top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [enums_top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js
  // source: https://stackoverflow.com/questions/49875255

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js

  var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
  var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          }); // Validate the provided modifiers so that the consumer will get warned
          // if one of the modifiers is invalid for any reason

          if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }

          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            if (false) {}

            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (false) {}

            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        if (false) {}

        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref3) {
          var name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options,
              effect = _ref3.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var createPopper =
  /*#__PURE__*/

  /* unused pure expression or super */
  null && 0; // eslint-disable-next-line import/no-unused-modules

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  // eslint-disable-next-line import/no-unused-modules

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case enums_top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;

        default:
      }
    }

    return offsets;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name; // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step

    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_popperOffsets = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  // eslint-disable-next-line import/no-unused-modules

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref) {
    var x = _ref.x,
        y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = enums_top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === enums_top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

    if (false) { var transitionProperty; }

    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_computeStyles = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  // This modifier takes the styles prepared by the `computeStyles` modifier
  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function applyStyles_effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_applyStyles = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: applyStyles_effect,
    requires: ['computeStyles']
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js
  // eslint-disable-next-line import/no-unused-modules

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = enums_placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_offset = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js

  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };

  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js

  var getOppositeVariationPlacement_hash = {
    start: 'end',
    end: 'start'
  };

  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return getOppositeVariationPlacement_hash[matched];
    });
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js

  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
      // errors due to floating point numbers, so we need to check precision.
      // Safari returns a number <= 0, usually < -1 when pinch-zoomed
      // Feature detection fails in mobile emulation mode in Chrome.
      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
      // 0.001
      // Fallback here: "Not Safari" userAgent

      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  // Gets the entire size of the scrollable document area, even extending outside
  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle(body || html).direction === 'rtl') {
      x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js

  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = math_max(rect.top, accRect.top);
      accRect.right = math_min(rect.right, accRect.right);
      accRect.bottom = math_min(rect.bottom, accRect.bottom);
      accRect.left = math_max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js
  // eslint-disable-next-line import/no-unused-modules

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements;

      if (false) {}
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js
  // eslint-disable-next-line import/no-unused-modules

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases  research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_flip = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js

  function within(min, value, max) {
    return math_max(min, math_min(value, max));
  }

  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? enums_top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min = offset + overflow[mainSide];
      var max = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? enums_top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_preventOverflow = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js
  // eslint-disable-next-line import/no-unused-modules

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? enums_top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function arrow_effect(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (false) {}

    if (!contains(state.elements.popper, arrowElement)) {
      if (false) {}

      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_arrow = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: arrow_effect,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [enums_top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules

  /* harmony default export */


  var modifiers_hide = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };
  ; // CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js

  var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];
  var popper_createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules
  // eslint-disable-next-line import/no-unused-modules
  // eslint-disable-next-line import/no-unused-modules

  ; // CONCATENATED MODULE: ./src/components/dropdown.js

  function dropdown_toConsumableArray(arr) {
    return dropdown_arrayWithoutHoles(arr) || dropdown_iterableToArray(arr) || dropdown_unsupportedIterableToArray(arr) || dropdown_nonIterableSpread();
  }

  function dropdown_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function dropdown_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return dropdown_arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dropdown_arrayLikeToArray(o, minLen);
  }

  function dropdown_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function dropdown_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return dropdown_arrayLikeToArray(arr);
  }

  function dropdown_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function dropdown_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function dropdown_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? dropdown_ownKeys(Object(source), !0).forEach(function (key) {
        dropdown_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : dropdown_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function dropdown_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function dropdown_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function dropdown_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function dropdown_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) dropdown_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) dropdown_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var dropdown_Default = {
    placement: 'bottom',
    triggerType: 'click',
    onShow: function onShow() {},
    onHide: function onHide() {}
  };

  var Dropdown = /*#__PURE__*/function () {
    function Dropdown() {
      var targetElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var triggerElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      dropdown_classCallCheck(this, Dropdown);
      this._targetEl = targetElement;
      this._triggerEl = triggerElement;
      this._options = dropdown_objectSpread(dropdown_objectSpread({}, dropdown_Default), options);
      this._popperInstance = this._createPopperInstace();
      this._visible = false;

      this._init();
    }

    dropdown_createClass(Dropdown, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._triggerEl) {
          this._triggerEl.addEventListener('click', function () {
            _this.toggle();
          });
        }
      }
    }, {
      key: "_createPopperInstace",
      value: function _createPopperInstace() {
        return popper_createPopper(this._triggerEl, this._targetEl, {
          placement: this._options.placement,
          modifiers: [{
            name: 'offset',
            options: {
              offset: [0, 10]
            }
          }]
        });
      }
    }, {
      key: "_handleClickOutside",
      value: function _handleClickOutside(ev, targetEl) {
        var clickedEl = ev.target;

        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this._visible) {
          this.hide();
        }

        document.body.removeEventListener('click', this._handleClickOutside, true);
      }
    }, {
      key: "toggle",
      value: function toggle() {
        if (this._visible) {
          this.hide();
          document.body.removeEventListener('click', this._handleClickOutside, true);
        } else {
          this.show();
        }
      }
    }, {
      key: "show",
      value: function show() {
        var _this2 = this;

        this._targetEl.classList.remove('hidden');

        this._targetEl.classList.add('block'); // Enable the event listeners


        this._popperInstance.setOptions(function (options) {
          return dropdown_objectSpread(dropdown_objectSpread({}, options), {}, {
            modifiers: [].concat(dropdown_toConsumableArray(options.modifiers), [{
              name: 'eventListeners',
              enabled: true
            }])
          });
        });

        document.body.addEventListener('click', function (ev) {
          _this2._handleClickOutside(ev, _this2._targetEl);
        }, true); // Update its position

        this._popperInstance.update();

        this._visible = true; // callback function

        this._options.onShow();
      }
    }, {
      key: "hide",
      value: function hide() {
        this._targetEl.classList.remove('block');

        this._targetEl.classList.add('hidden'); // Disable the event listeners


        this._popperInstance.setOptions(function (options) {
          return dropdown_objectSpread(dropdown_objectSpread({}, options), {}, {
            modifiers: [].concat(dropdown_toConsumableArray(options.modifiers), [{
              name: 'eventListeners',
              enabled: false
            }])
          });
        });

        this._visible = false; // callback function

        this._options.onHide();
      }
    }]);
    return Dropdown;
  }();

  window.Dropdown = Dropdown;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-dropdown-toggle]').forEach(function (triggerEl) {
      var targetEl = document.getElementById(triggerEl.getAttribute('data-dropdown-toggle'));
      var placement = triggerEl.getAttribute('data-dropdown-placement');
      new Dropdown(targetEl, triggerEl, {
        placement: placement ? placement : dropdown_Default.placement
      });
    });
  });
  /* harmony default export */

  var dropdown = Dropdown;
  ; // CONCATENATED MODULE: ./src/components/modal.js

  function modal_toConsumableArray(arr) {
    return modal_arrayWithoutHoles(arr) || modal_iterableToArray(arr) || modal_unsupportedIterableToArray(arr) || modal_nonIterableSpread();
  }

  function modal_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function modal_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return modal_arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return modal_arrayLikeToArray(o, minLen);
  }

  function modal_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function modal_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return modal_arrayLikeToArray(arr);
  }

  function modal_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function modal_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function modal_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? modal_ownKeys(Object(source), !0).forEach(function (key) {
        modal_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : modal_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function modal_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function modal_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function modal_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function modal_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) modal_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) modal_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var modal_Default = {
    placement: 'center',
    backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
    onHide: function onHide() {},
    onShow: function onShow() {},
    onToggle: function onToggle() {}
  };

  var Modal = /*#__PURE__*/function () {
    function Modal() {
      var targetEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      modal_classCallCheck(this, Modal);
      this._targetEl = targetEl;
      this._options = modal_objectSpread(modal_objectSpread({}, modal_Default), options);
      this._isHidden = true;

      this._init();
    }

    modal_createClass(Modal, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        this._getPlacementClasses().map(function (c) {
          _this._targetEl.classList.add(c);
        });
      }
    }, {
      key: "_createBackdrop",
      value: function _createBackdrop() {
        if (this._isHidden) {
          var _backdropEl$classList;

          var backdropEl = document.createElement('div');
          backdropEl.setAttribute('modal-backdrop', '');

          (_backdropEl$classList = backdropEl.classList).add.apply(_backdropEl$classList, modal_toConsumableArray(this._options.backdropClasses.split(" ")));

          document.querySelector('body').append(backdropEl);
        }
      }
    }, {
      key: "_destroyBackdropEl",
      value: function _destroyBackdropEl() {
        if (!this._isHidden) {
          document.querySelector('[modal-backdrop]').remove();
        }
      }
    }, {
      key: "_getPlacementClasses",
      value: function _getPlacementClasses() {
        switch (this._options.placement) {
          // top
          case 'top-left':
            return ['justify-start', 'items-start'];

          case 'top-center':
            return ['justify-center', 'items-start'];

          case 'top-right':
            return ['justify-end', 'items-start'];
          // center

          case 'center-left':
            return ['justify-start', 'items-center'];

          case 'center':
            return ['justify-center', 'items-center'];

          case 'center-right':
            return ['justify-end', 'items-center'];
          // bottom

          case 'bottom-left':
            return ['justify-start', 'items-end'];

          case 'bottom-center':
            return ['justify-center', 'items-end'];

          case 'bottom-right':
            return ['justify-end', 'items-end'];

          default:
            return ['justify-center', 'items-center'];
        }
      }
    }, {
      key: "toggle",
      value: function toggle() {
        if (this._isHidden) {
          this.show();
        } else {
          this.hide();
        } // callback function


        this._options.onToggle();
      }
    }, {
      key: "show",
      value: function show() {
        this._targetEl.classList.add('flex');

        this._targetEl.classList.remove('hidden');

        this._targetEl.setAttribute('aria-modal', 'true');

        this._targetEl.setAttribute('role', 'dialog');

        this._targetEl.removeAttribute('aria-hidden');

        this._createBackdrop();

        this._isHidden = false; // callback function

        this._options.onShow();
      }
    }, {
      key: "hide",
      value: function hide() {
        this._targetEl.classList.add('hidden');

        this._targetEl.classList.remove('flex');

        this._targetEl.setAttribute('aria-hidden', 'true');

        this._targetEl.removeAttribute('aria-modal');

        this._targetEl.removeAttribute('role');

        this._destroyBackdropEl();

        this._isHidden = true; // callback function

        this._options.onHide();
      }
    }]);
    return Modal;
  }();

  window.Modal = Modal;

  var getModalInstance = function getModalInstance(id, instances) {
    if (instances.some(function (modalInstance) {
      return modalInstance.id === id;
    })) {
      return instances.find(function (modalInstance) {
        return modalInstance.id === id;
      });
    }

    return false;
  };

  document.addEventListener('DOMContentLoaded', function () {
    var modalInstances = [];
    document.querySelectorAll('[data-modal-toggle]').forEach(function (el) {
      var modalId = el.getAttribute('data-modal-toggle');
      var modalEl = document.getElementById(modalId);
      var placement = modalEl.getAttribute('data-modal-placement');

      if (modalEl) {
        if (!modalEl.hasAttribute('aria-hidden') && !modalEl.hasAttribute('aria-modal')) {
          modalEl.setAttribute('aria-hidden', 'true');
        }
      }

      var modal = null;

      if (getModalInstance(modalId, modalInstances)) {
        modal = getModalInstance(modalId, modalInstances);
        modal = modal.object;
      } else {
        modal = new Modal(modalEl, {
          placement: placement ? placement : modal_Default.placement
        });
        modalInstances.push({
          id: modalId,
          object: modal
        });
      }

      el.addEventListener('click', function () {
        modal.toggle();
      });
    });
  });
  /* harmony default export */

  var modal = Modal;
  ; // CONCATENATED MODULE: ./src/components/tabs.js

  function tabs_toConsumableArray(arr) {
    return tabs_arrayWithoutHoles(arr) || tabs_iterableToArray(arr) || tabs_unsupportedIterableToArray(arr) || tabs_nonIterableSpread();
  }

  function tabs_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function tabs_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return tabs_arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tabs_arrayLikeToArray(o, minLen);
  }

  function tabs_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function tabs_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return tabs_arrayLikeToArray(arr);
  }

  function tabs_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function tabs_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function tabs_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? tabs_ownKeys(Object(source), !0).forEach(function (key) {
        tabs_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : tabs_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function tabs_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function tabs_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function tabs_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function tabs_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) tabs_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) tabs_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var tabs_Default = {
    defaultTabId: null,
    activeClasses: 'text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-400 border-blue-600 dark:border-blue-500',
    inactiveClasses: 'text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300',
    onShow: function onShow() {}
  };

  var Tabs = /*#__PURE__*/function () {
    function Tabs() {
      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      tabs_classCallCheck(this, Tabs);
      this._items = items;
      this._activeTab = options ? this.getTab(options.defaultTabId) : null;
      this._options = tabs_objectSpread(tabs_objectSpread({}, tabs_Default), options);

      this._init();
    }

    tabs_createClass(Tabs, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._items.length) {
          // set the first tab as active if not set by explicitly
          if (!this._activeTab) {
            this._setActiveTab(this._items[0]);
          } // force show the first default tab


          this.show(this._activeTab.id, true); // show tab content based on click

          this._items.map(function (tab) {
            tab.triggerEl.addEventListener('click', function () {
              _this.show(tab.id);
            });
          });
        }
      }
    }, {
      key: "getActiveTab",
      value: function getActiveTab() {
        return this._activeTab;
      }
    }, {
      key: "_setActiveTab",
      value: function _setActiveTab(tab) {
        this._activeTab = tab;
      }
    }, {
      key: "getTab",
      value: function getTab(id) {
        return this._items.filter(function (t) {
          return t.id === id;
        })[0];
      }
    }, {
      key: "show",
      value: function show(id) {
        var _this2 = this,
            _tab$triggerEl$classL,
            _tab$triggerEl$classL2;

        var forceShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var tab = this.getTab(id); // don't do anything if already active

        if (tab === this._activeTab && !forceShow) {
          return;
        } // hide other tabs


        this._items.map(function (t) {
          if (t !== tab) {
            var _t$triggerEl$classLis, _t$triggerEl$classLis2;

            (_t$triggerEl$classLis = t.triggerEl.classList).remove.apply(_t$triggerEl$classLis, tabs_toConsumableArray(_this2._options.activeClasses.split(" ")));

            (_t$triggerEl$classLis2 = t.triggerEl.classList).add.apply(_t$triggerEl$classLis2, tabs_toConsumableArray(_this2._options.inactiveClasses.split(" ")));

            t.targetEl.classList.add('hidden');
            t.triggerEl.setAttribute('aria-selected', false);
          }
        }); // show active tab


        (_tab$triggerEl$classL = tab.triggerEl.classList).add.apply(_tab$triggerEl$classL, tabs_toConsumableArray(this._options.activeClasses.split(" ")));

        (_tab$triggerEl$classL2 = tab.triggerEl.classList).remove.apply(_tab$triggerEl$classL2, tabs_toConsumableArray(this._options.inactiveClasses.split(" ")));

        tab.triggerEl.setAttribute('aria-selected', true);
        tab.targetEl.classList.remove('hidden');

        this._setActiveTab(tab); // callback function


        this._options.onShow();
      }
    }]);
    return Tabs;
  }();

  window.Tabs = Tabs;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-tabs-toggle]').forEach(function (triggerEl) {
      var tabElements = [];
      var defaultTabId = null;
      triggerEl.querySelectorAll('[role="tab"]').forEach(function (el) {
        var isActive = el.getAttribute('aria-selected') === 'true';
        var tab = {
          id: el.getAttribute('data-tabs-target'),
          triggerEl: el,
          targetEl: document.querySelector(el.getAttribute('data-tabs-target'))
        };
        tabElements.push(tab);

        if (isActive) {
          defaultTabId = tab.id;
        }
      });
      new Tabs(tabElements, {
        defaultTabId: defaultTabId
      });
    });
  });
  /* harmony default export */

  var tabs = Tabs;
  ; // CONCATENATED MODULE: ./src/components/tooltip.js

  function tooltip_toConsumableArray(arr) {
    return tooltip_arrayWithoutHoles(arr) || tooltip_iterableToArray(arr) || tooltip_unsupportedIterableToArray(arr) || tooltip_nonIterableSpread();
  }

  function tooltip_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function tooltip_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return tooltip_arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltip_arrayLikeToArray(o, minLen);
  }

  function tooltip_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function tooltip_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return tooltip_arrayLikeToArray(arr);
  }

  function tooltip_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function tooltip_ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function tooltip_objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? tooltip_ownKeys(Object(source), !0).forEach(function (key) {
        tooltip_defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : tooltip_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function tooltip_defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function tooltip_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function tooltip_defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function tooltip_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) tooltip_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) tooltip_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var tooltip_Default = {
    placement: 'top',
    triggerType: 'hover',
    onShow: function onShow() {},
    onHide: function onHide() {}
  };

  var Tooltip = /*#__PURE__*/function () {
    function Tooltip() {
      var targetEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var triggerEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      tooltip_classCallCheck(this, Tooltip);
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = tooltip_objectSpread(tooltip_objectSpread({}, tooltip_Default), options);
      this._popperInstance = this._createPopperInstace();

      this._init();
    }

    tooltip_createClass(Tooltip, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        if (this._triggerEl) {
          var triggerEvents = this._getTriggerEvents();

          triggerEvents.showEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
              _this.show();
            });
          });
          triggerEvents.hideEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
              _this.hide();
            });
          });
        }
      }
    }, {
      key: "_createPopperInstace",
      value: function _createPopperInstace() {
        return popper_createPopper(this._triggerEl, this._targetEl, {
          placement: this._options.placement,
          modifiers: [{
            name: 'offset',
            options: {
              offset: [0, 8]
            }
          }]
        });
      }
    }, {
      key: "_getTriggerEvents",
      value: function _getTriggerEvents() {
        switch (this._options.triggerType) {
          case 'hover':
            return {
              showEvents: ['mouseenter', 'focus'],
              hideEvents: ['mouseleave', 'blur']
            };

          case 'click':
            return {
              showEvents: ['click', 'focus'],
              hideEvents: ['focusout', 'blur']
            };

          default:
            return {
              showEvents: ['mouseenter', 'focus'],
              hideEvents: ['mouseleave', 'blur']
            };
        }
      }
    }, {
      key: "show",
      value: function show() {
        this._targetEl.classList.remove('opacity-0', 'invisible');

        this._targetEl.classList.add('opacity-100', 'visible'); // Enable the event listeners


        this._popperInstance.setOptions(function (options) {
          return tooltip_objectSpread(tooltip_objectSpread({}, options), {}, {
            modifiers: [].concat(tooltip_toConsumableArray(options.modifiers), [{
              name: 'eventListeners',
              enabled: true
            }])
          });
        }); // Update its position


        this._popperInstance.update(); // callback function


        this._options.onShow();
      }
    }, {
      key: "hide",
      value: function hide() {
        this._targetEl.classList.remove('opacity-100', 'visible');

        this._targetEl.classList.add('opacity-0', 'invisible'); // Disable the event listeners


        this._popperInstance.setOptions(function (options) {
          return tooltip_objectSpread(tooltip_objectSpread({}, options), {}, {
            modifiers: [].concat(tooltip_toConsumableArray(options.modifiers), [{
              name: 'eventListeners',
              enabled: false
            }])
          });
        }); // callback function


        this._options.onHide();
      }
    }]);
    return Tooltip;
  }();

  window.Tooltip = Tooltip;
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('[data-tooltip-target]').forEach(function (triggerEl) {
      var targetEl = document.getElementById(triggerEl.getAttribute('data-tooltip-target'));
      var triggerType = triggerEl.getAttribute('data-tooltip-trigger');
      var placement = triggerEl.getAttribute('data-tooltip-placement');
      new Tooltip(targetEl, triggerEl, {
        placement: placement ? placement : tooltip_Default.placement,
        triggerType: triggerType ? triggerType : tooltip_Default.triggerType
      });
    });
  });
  /* harmony default export */

  var tooltip = Tooltip;
  ; // CONCATENATED MODULE: ./src/flowbite.js
  // core components

  /* harmony default export */

  var flowbite = {
    Accordion: accordion,
    Collapse: collapse,
    Carousel: carousel,
    Dismiss: dismiss,
    Dropdown: dropdown,
    Modal: modal,
    Tabs: tabs,
    Tooltip: tooltip
  };
  /******/
})();

/***/ }),

/***/ "./src/main.css":
/*!**********************!*\
  !*** ./src/main.css ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/locator/time.ts":
/*!*****************************!*\
  !*** ./src/locator/time.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatOpenNowString": () => (/* binding */ formatOpenNowString),
/* harmony export */   "parseTimeZoneUtcOffset": () => (/* binding */ parseTimeZoneUtcOffset)
/* harmony export */ });
// Formats hours function
// Open  Closes at 5pm
// Closed  Open at 6am
function formatOpenNowString(hoursData, utcOffset) {
  var now = getYextTimeWithUtcOffset(utcOffset);
  var tomorrow = new Date(now.getTime() + 60 * 60 * 24 * 1000);
  var yesterday = new Date(now.getTime() - 60 * 60 * 24 * 1000);
  var nowTimeNumber = now.getHours() + now.getMinutes() / 60;
  var intervalsToday = getIntervalOnDate(now, hoursData);
  var intervalsTomorrow = getIntervalOnDate(tomorrow, hoursData);
  var intervalsYesterday = getIntervalOnDate(yesterday, hoursData);
  var openRightNow = false;
  var currentInterval = null;
  var nextInterval = null;

  if (intervalsYesterday) {
    for (var i = 0; i < intervalsYesterday.length; i++) {
      var interval = intervalsYesterday[i];
      var startIntervalNumber = timeStringToNumber(interval.start);
      var endIntervalNumber = timeStringToNumber(interval.end); // If end overflows to the next day (i.e. today).

      if (endIntervalNumber < startIntervalNumber) {
        if (nowTimeNumber < endIntervalNumber) {
          currentInterval = interval;
          openRightNow = true;
        }
      }
    }
  } // Assumes no overlapping intervals


  if (intervalsToday) {
    for (var i = 0; i < intervalsToday.length; i++) {
      var interval = intervalsToday[i];
      var startIntervalNumber = timeStringToNumber(interval.start);
      var endIntervalNumber = timeStringToNumber(interval.end); // If current time doesn't belong to one of yesterdays interval.

      if (currentInterval == null) {
        if (endIntervalNumber < startIntervalNumber) {
          if (nowTimeNumber >= startIntervalNumber) {
            currentInterval = interval;
            openRightNow = true;
          }
        } else if (nowTimeNumber >= startIntervalNumber && nowTimeNumber < endIntervalNumber) {
          currentInterval = interval;
          openRightNow = true;
        }
      }

      if (nextInterval == null) {
        if (startIntervalNumber > nowTimeNumber) {
          nextInterval = interval;
        }
      } else {
        if (startIntervalNumber > nowTimeNumber && startIntervalNumber < timeStringToNumber(nextInterval.start)) {
          nextInterval = interval;
        }
      }
    }
  }

  var nextIsTomorrow = false; // If no more intervals in the day

  if (nextInterval == null) {
    if (intervalsTomorrow) {
      if (intervalsTomorrow.length > 0) {
        nextInterval = intervalsTomorrow[0];
        nextIsTomorrow = true;
      }
    }
  }

  var hoursString = "";

  if (nextInterval) {
    if (openRightNow) {
      // Check first for a 24-hour interval, then check for open past midnight
      if (currentInterval.start == "00:00" && currentInterval.end == "23:59") {
        hoursString += "<strong>Open 24 hours</strong>";
      } else if (nextInterval.start == "00:00" && currentInterval.end == "23:59") {
        hoursString += "<strong>Open</strong>  Closes at [closingTime] tomorrow";
        hoursString = hoursString.replace("[closingTime]", // formatTime(currentInterval.end)
        currentInterval.end);
      } else {
        hoursString += "<strong>Open</strong>  Closes at [closingTime]";
        hoursString = hoursString.replace("[closingTime]", // formatTime(currentInterval.end)
        currentInterval.end);
      }
    } else {
      if (nextIsTomorrow) {
        hoursString += "<strong>Closed</strong>  Opens at [openingTime] tomorrow";
        hoursString = hoursString.replace("[openingTime]", // formatTime(nextInterval.start)
        nextInterval.start);
      } else {
        hoursString += "<strong>Closed</strong>  Opens at [openingTime]";
        hoursString = hoursString.replace("[openingTime]", // formatTime(nextInterval.start)
        nextInterval.start);
      }
    }
  }

  return hoursString;
}

function formatTime(time) {
  var tempDate = new Date("January 1, 2020 " + time);
  var localeString = "en-US";
  return tempDate.toLocaleTimeString(localeString.replace("_", "-"), {
    hour: "numeric",
    minute: "numeric"
  });
}

function timeStringToNumber(timeString) {
  var parts = timeString.split(":");
  var hours = parseInt(parts[0].replace(/\u200E/g, ""), 10);
  var minutes = parseInt(parts[1].replace(/\u200E/g, ""), 10);
  return hours + minutes / 60;
}

function getYextTimeWithUtcOffset(entityUtcOffsetSeconds) {
  var now = new Date();
  var utcOffset = 0;

  if (entityUtcOffsetSeconds) {
    utcOffset = entityUtcOffsetSeconds * 1000;
  }

  if (utcOffset !== 0) {
    var localUtcOffset = now.getTimezoneOffset() * 60 * 1000;
    return new Date(now.valueOf() + utcOffset + localUtcOffset);
  }

  return now;
} // Parses an offset formatted like {+/-}{04}:{00}


function parseTimeZoneUtcOffset(timeString) {
  if (!timeString) {
    return 0;
  }

  var parts = timeString.split(":");
  var hours = parseInt(parts[0].replace(/\u200E/g, ""), 10);
  var minutes = parseInt(parts[1].replace(/\u200E/g, ""), 10);

  if (hours < 0) {
    return -(Math.abs(hours) + minutes / 60) * 60 * 60;
  }

  return (hours + minutes / 60) * 60 * 60;
}

function getIntervalOnDate(date, hoursData) {
  var day = date.getDate();
  var month = date.getMonth() + 1;
  var year = date.getFullYear();
  var days = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  var dateString = year + "-" + (month < 10 ? "0" + month : month) + "-" + (day < 10 ? "0" + day : day);
  var dayOfWeekString = days[date.getDay()]; // Check for holiday

  if (hoursData.holidayHours) {
    for (var i = 0; i < hoursData.holidayHours.length; i++) {
      var holiday = hoursData.holidayHours[i];

      if (holiday.date == dateString) {
        if (holiday.openIntervals) {
          return holiday.openIntervals;
        } else if (holiday.isClosed === true) {
          return null; // On holiday but closed
        }
      }
    }
  } // Not on holiday


  if (hoursData[dayOfWeekString] && hoursData[dayOfWeekString].openIntervals) {
    return hoursData[dayOfWeekString].openIntervals;
  } else {
    return null;
  }
}

/***/ }),

/***/ "./src/images sync \\.(png|jpe?g|svg|webp)$":
/*!***************************************************************!*\
  !*** ./src/images/ sync nonrecursive \.(png|jpe?g|svg|webp)$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./address.svg": "./src/images/address.svg",
	"./banner.webp": "./src/images/banner.webp",
	"./left-arrow.svg": "./src/images/left-arrow.svg",
	"./luxurystore.jpeg": "./src/images/luxurystore.jpeg",
	"./phone.svg": "./src/images/phone.svg",
	"./right-arrow.svg": "./src/images/right-arrow.svg",
	"./slide.webp": "./src/images/slide.webp",
	"./time.svg": "./src/images/time.svg",
	"./yext-favicon.png": "./src/images/yext-favicon.png",
	"./yext-logo.svg": "./src/images/yext-logo.svg"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./src/images sync \\.(png|jpe?g|svg|webp)$";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ "./src/main.css");
/* harmony import */ var flowbite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/dist/flowbite.js");
/* harmony import */ var flowbite__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(flowbite__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _src_locator_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../src/locator/time */ "./src/locator/time.ts");




function importAll(r) {
  var images = {};
  r.keys().map(function (item, index) {
    images[item.replace('./', '')] = r(item);
  });
  return images;
}

var images = importAll(__webpack_require__("./src/images sync \\.(png|jpe?g|svg|webp)$"));
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uL3NyYy9pbWFnZXMvYWRkcmVzcy5zdmciLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi9zcmMvaW1hZ2VzL2Jhbm5lci53ZWJwIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL2ltYWdlcy9sZWZ0LWFycm93LnN2ZyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uL3NyYy9pbWFnZXMvbHV4dXJ5c3RvcmUuanBlZyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uL3NyYy9pbWFnZXMvcGhvbmUuc3ZnIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL2ltYWdlcy9yaWdodC1hcnJvdy5zdmciLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi9zcmMvaW1hZ2VzL3NsaWRlLndlYnAiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi9zcmMvaW1hZ2VzL3RpbWUuc3ZnIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL2ltYWdlcy95ZXh0LWZhdmljb24ucG5nIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL2ltYWdlcy95ZXh0LWxvZ28uc3ZnIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9jYXJvdXNlbC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9kaXNtaXNzLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9kcm9wZG93bi5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9tb2RhbC5qcyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy90YWJzLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi4vLi4vLi4vLi4vLi4vc3JjL2Zsb3diaXRlLmpzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL21haW4uY3NzIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyLy4vc3JjL2xvY2F0b3IvdGltZS50cyIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci8uL3NyYy9pbWFnZXN8c3luY3xub25yZWN1cnNpdmV8Ly4ocG5nfGpwZSIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zaXRlcy1sb2NhdGlvbnMtc3RhcnRlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NpdGVzLWxvY2F0aW9ucy1zdGFydGVyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vc2l0ZXMtbG9jYXRpb25zLXN0YXJ0ZXIvLi9zcmMvbWFpbi5qcyJdLCJuYW1lcyI6WyJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsIkRlZmF1bHQiLCJhbHdheXNPcGVuIiwiYWN0aXZlQ2xhc3NlcyIsImluYWN0aXZlQ2xhc3NlcyIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJBY2NvcmRpb24iLCJpdGVtcyIsIm9wdGlvbnMiLCJpdGVtIiwiaSIsIndpbmRvdyIsImRvY3VtZW50IiwiYWNjb3JkaW9uRWwiLCJpZCIsImVsIiwidHJpZ2dlckVsIiwidGFyZ2V0RWwiLCJpY29uRWwiLCJhY3RpdmUiLCJvbkNvbGxhcHNlIiwib25FeHBhbmQiLCJvblRvZ2dsZSIsIkNvbGxhcHNlIiwiZGVmYXVsdFBvc2l0aW9uIiwiaW5kaWNhdG9ycyIsImludGVydmFsIiwib25OZXh0Iiwib25QcmV2Iiwib25DaGFuZ2UiLCJDYXJvdXNlbCIsImluZGljYXRvciIsIm5leHRJdGVtIiwicm90YXRpb25JdGVtcyIsImFjdGl2ZUl0ZW0iLCJwcmV2SXRlbSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNhcm91c2VsRWwiLCJzbGlkZSIsInBvc2l0aW9uIiwiY2Fyb3VzZWxJdGVtRWwiLCJpbmRpY2F0b3JFbCIsImNhcm91c2VsIiwiY2Fyb3VzZWxOZXh0RWwiLCJjYXJvdXNlbFByZXZFbCIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsInRpbWluZyIsIm9uSGlkZSIsIkRpc21pc3MiLCJzZXRUaW1lb3V0IiwicGxhY2VtZW50IiwidHJpZ2dlclR5cGUiLCJvblNob3ciLCJEcm9wZG93biIsInRhcmdldEVsZW1lbnQiLCJ0cmlnZ2VyRWxlbWVudCIsImNyZWF0ZVBvcHBlciIsIm1vZGlmaWVycyIsIm5hbWUiLCJvZmZzZXQiLCJjbGlja2VkRWwiLCJldiIsImVuYWJsZWQiLCJiYWNrZHJvcENsYXNzZXMiLCJNb2RhbCIsImJhY2tkcm9wRWwiLCJnZXRNb2RhbEluc3RhbmNlIiwibW9kYWxJbnN0YW5jZSIsIm1vZGFsSW5zdGFuY2VzIiwibW9kYWxJZCIsIm1vZGFsRWwiLCJtb2RhbCIsIm9iamVjdCIsImRlZmF1bHRUYWJJZCIsIlRhYnMiLCJ0YWIiLCJ0IiwiZm9yY2VTaG93IiwidGFiRWxlbWVudHMiLCJpc0FjdGl2ZSIsIlRvb2x0aXAiLCJ0cmlnZ2VyRXZlbnRzIiwic2hvd0V2ZW50cyIsImhpZGVFdmVudHMiLCJpbXBvcnRBbGwiLCJyIiwiaW1hZ2VzIiwia2V5cyIsIm1hcCIsImluZGV4IiwicmVwbGFjZSIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUVBQWVBLHFCQUF1QixHQUFHLG9CQUF6QyxFOzs7Ozs7Ozs7Ozs7Ozs7QUNBQSxpRUFBZUEscUJBQXVCLEdBQUcsb0JBQXpDLEU7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLGlFQUFlQSxxQkFBdUIsR0FBRyx1QkFBekMsRTs7Ozs7Ozs7Ozs7Ozs7O0FDQUEsaUVBQWVBLHFCQUF1QixHQUFHLHlCQUF6QyxFOzs7Ozs7Ozs7Ozs7Ozs7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O1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGtDOzs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQU1BLFNBQVNJLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCO0FBQ2xCLE1BQUlDLE1BQU0sR0FBRyxFQUFiO0FBQ0FELEdBQUMsQ0FBQ0UsSUFBRixHQUFTQyxHQUFULENBQWEsVUFBQ2pGLElBQUQsRUFBT2tGLEtBQVAsRUFBaUI7QUFBRUgsVUFBTSxDQUFDL0UsSUFBSSxDQUFDbUYsT0FBTCxDQUFhLElBQWIsRUFBbUIsRUFBbkIsQ0FBRCxDQUFOLEdBQWlDTCxDQUFDLENBQUM5RSxJQUFELENBQWxDO0FBQTJDLEdBQTNFO0FBQ0EsU0FBTytFLE1BQVA7QUFDRDs7QUFFRCxJQUFNQSxNQUFNLEdBQUdGLFNBQVMsQ0FBQ08saUVBQUQsQ0FBeEIsQyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9hZGRyZXNzLnN2Z1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvYmFubmVyLndlYnBcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL2xlZnQtYXJyb3cuc3ZnXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9sdXh1cnlzdG9yZS5qcGVnXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9waG9uZS5zdmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL3JpZ2h0LWFycm93LnN2Z1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvc2xpZGUud2VicFwiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWFnZXMvdGltZS5zdmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL3lleHQtZmF2aWNvbi5wbmdcIjsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL3lleHQtbG9nby5zdmdcIjsiLCJjb25zdCBEZWZhdWx0ID0ge1xuICAgIGFsd2F5c09wZW46IGZhbHNlLFxuICAgIGFjdGl2ZUNsYXNzZXM6ICdiZy1ncmF5LTEwMCBkYXJrOmJnLWdyYXktODAwIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlJyxcbiAgICBpbmFjdGl2ZUNsYXNzZXM6ICd0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCcsXG4gICAgb25PcGVuOiAoKSA9PiB7IH0sXG4gICAgb25DbG9zZTogKCkgPT4geyB9XG59XG5cbmNsYXNzIEFjY29yZGlvbiB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXNcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsgLi4uRGVmYXVsdCwgLi4ub3B0aW9ucyB9XG4gICAgICAgIHRoaXMuX2luaXQoKVxuICAgIH1cblxuICAgIF9pbml0KCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzaG93IGFjY29yZGlvbiBpdGVtIGJhc2VkIG9uIGNsaWNrXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5tYXAoaXRlbSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuKGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS50cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJdGVtKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmlkID09PSBpZClbMF1cbiAgICB9XG5cbiAgICBvcGVuKGlkKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpXG5cbiAgICAgICAgLy8gZG9uJ3QgaGlkZSBvdGhlciBhY2NvcmRpb25zIGlmIGFsd2F5cyBvcGVuXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hbHdheXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5tYXAoaSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaS50cmlnZ2VyRWwuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgICAgICBpLnRyaWdnZXJFbC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICAgICAgaS50YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICBpLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgaS5hY3RpdmUgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdGF0ZSBpY29uIGlmIHNldFxuICAgICAgICAgICAgICAgICAgICBpZiAoaS5pY29uRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuaWNvbkVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZS0xODAnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3cgYWN0aXZlIGl0ZW1cbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICBpdGVtLnRyaWdnZXJFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgICAgaXRlbS50YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuICAgICAgICBpdGVtLmFjdGl2ZSA9IHRydWVcblxuICAgICAgICAvLyByb3RhdGUgaWNvbiBpZiBzZXRcbiAgICAgICAgaWYgKGl0ZW0uaWNvbkVsKSB7XG4gICAgICAgICAgICBpdGVtLmljb25FbC5jbGFzc0xpc3QuYWRkKCdyb3RhdGUtMTgwJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25PcGVuKGl0ZW0pXG4gICAgfVxuXG4gICAgdG9nZ2xlKGlkKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpXG5cbiAgICAgICAgaWYgKGl0ZW0uYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKGlkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZShpdGVtKVxuICAgIH1cblxuICAgIGNsb3NlKGlkKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpXG5cbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICBpdGVtLnRyaWdnZXJFbC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgaXRlbS50YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICBpdGVtLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgaXRlbS5hY3RpdmUgPSBmYWxzZVxuXG4gICAgICAgIC8vIHJvdGF0ZSBpY29uIGlmIHNldFxuICAgICAgICBpZiAoaXRlbS5pY29uRWwpIHtcbiAgICAgICAgICAgIGl0ZW0uaWNvbkVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZS0xODAnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNsb3NlKGl0ZW0pXG4gICAgfVxuXG59XG5cbndpbmRvdy5BY2NvcmRpb24gPSBBY2NvcmRpb247XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYWNjb3JkaW9uXScpLmZvckVhY2goYWNjb3JkaW9uRWwgPT4ge1xuXG4gICAgICAgIGNvbnN0IGFsd2F5c09wZW4gPSBhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uJylcbiAgICAgICAgY29uc3QgYWN0aXZlQ2xhc3NlcyA9IGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY3RpdmUtY2xhc3NlcycpXG4gICAgICAgIGNvbnN0IGluYWN0aXZlQ2xhc3NlcyA9IGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmFjdGl2ZS1jbGFzc2VzJylcblxuICAgICAgICBjb25zdCBpdGVtcyA9IFtdXG4gICAgICAgIGFjY29yZGlvbkVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFjY29yZGlvbi10YXJnZXRdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uLXRhcmdldCcpLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFbDogZWwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFjY29yZGlvbi10YXJnZXQnKSksXG4gICAgICAgICAgICAgICAgaWNvbkVsOiBlbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY2NvcmRpb24taWNvbl0nKSxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgICAgfSlcblxuICAgICAgICBuZXcgQWNjb3JkaW9uKGl0ZW1zLCB7XG4gICAgICAgICAgICBhbHdheXNPcGVuOiBhbHdheXNPcGVuID09PSAnb3BlbicgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICBhY3RpdmVDbGFzc2VzOiBhY3RpdmVDbGFzc2VzID8gYWN0aXZlQ2xhc3NlcyA6IERlZmF1bHQuYWN0aXZlQ2xhc3NlcyxcbiAgICAgICAgICAgIGluYWN0aXZlQ2xhc3NlczogaW5hY3RpdmVDbGFzc2VzID8gaW5hY3RpdmVDbGFzc2VzIDogRGVmYXVsdC5pbmFjdGl2ZUNsYXNzZXNcbiAgICAgICAgfSlcbiAgICB9KVxufSlcblxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uIiwiY29uc3QgRGVmYXVsdCA9IHtcbiAgICB0cmlnZ2VyRWw6IG51bGwsXG4gICAgb25Db2xsYXBzZTogKCkgPT4geyB9LFxuICAgIG9uRXhwYW5kOiAoKSA9PiB7IH0sXG4gICAgb25Ub2dnbGU6ICgpID0+IHsgfVxufVxuXG5jbGFzcyBDb2xsYXBzZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0RWwgPSBudWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWxcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gb3B0aW9ucyA/IG9wdGlvbnMudHJpZ2dlckVsIDogRGVmYXVsdC50cmlnZ2VyRWxcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsgLi4uRGVmYXVsdCwgLi4ub3B0aW9ucyB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZVxuICAgICAgICB0aGlzLl9pbml0KClcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRoaXMuX3RyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZpeCB1bnRpbCB2MiBub3QgdG8gYnJlYWsgcHJldmlvdXMgc2luZ2xlIGNvbGxhcHNlcyB3aGljaCBiZWNhbWUgZGlzbWlzc1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGRlbicpID8gZmFsc2UgOiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID8gdGhpcy5jb2xsYXBzZSgpIDogdGhpcy5leHBhbmQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29sbGFwc2UoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXG4gICAgICAgIGlmKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNvbGxhcHNlKClcbiAgICB9XG5cbiAgICBleHBhbmQoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXG4gICAgICAgIGlmKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZVxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25FeHBhbmQoKVxuICAgIH1cblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbndpbmRvdy5Db2xsYXBzZSA9IENvbGxhcHNlO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbGxhcHNlLXRvZ2dsZV0nKS5mb3JFYWNoKHRyaWdnZXJFbCA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsYXBzZS10b2dnbGUnKSlcbiAgICAgICAgbmV3IENvbGxhcHNlKHRhcmdldEVsLCB7XG4gICAgICAgICAgICB0cmlnZ2VyRWw6IHRyaWdnZXJFbFxuICAgICAgICB9KVxuICAgIH0pXG59KVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZSIsImNvbnN0IERlZmF1bHQgPSB7XG4gICAgZGVmYXVsdFBvc2l0aW9uOiAwLFxuICAgIGluZGljYXRvcnM6IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBhY3RpdmVDbGFzc2VzOiAnYmctd2hpdGUgZGFyazpiZy1ncmF5LTgwMCcsXG4gICAgICAgIGluYWN0aXZlQ2xhc3NlczogJ2JnLXdoaXRlLzUwIGRhcms6YmctZ3JheS04MDAvNTAgaG92ZXI6Ymctd2hpdGUgZGFyazpob3ZlcjpiZy1ncmF5LTgwMCdcbiAgICB9LFxuICAgIGludGVydmFsOiAzMDAwLFxuICAgIG9uTmV4dDogKCkgPT4geyB9LFxuICAgIG9uUHJldjogKCkgPT4geyB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7IH1cbn1cblxuY2xhc3MgQ2Fyb3VzZWwge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7IC4uLkRlZmF1bHQsIC4uLm9wdGlvbnMsIGluZGljYXRvcnMgOiB7IC4uLkRlZmF1bHQuaW5kaWNhdG9ycywgLi4ub3B0aW9ucy5pbmRpY2F0b3JzIH0gfVxuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gdGhpcy5nZXRJdGVtKHRoaXMuX29wdGlvbnMuZGVmYXVsdFBvc2l0aW9uKVxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzID0gdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLml0ZW1zXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgICAgICB0aGlzLl9pbml0KClcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgY2Fyb3VzZWwgYW5kIGl0ZW1zIGJhc2VkIG9uIGFjdGl2ZSBvbmVcbiAgICAgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy5faXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5lbC5jbGFzc0xpc3QuYWRkKCdhYnNvbHV0ZScsICdpbnNldC0wJywgJ3RyYW5zaXRpb24tYWxsJywgJ3RyYW5zZm9ybScpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gaWYgbm8gYWN0aXZlIGl0ZW0gaXMgc2V0IHRoZW4gZmlyc3QgcG9zaXRpb24gaXMgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5fZ2V0QWN0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlVG8odGhpcy5fZ2V0QWN0aXZlSXRlbSgpLnBvc2l0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zbGlkZVRvKDApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzLm1hcCgoaW5kaWNhdG9yLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgaW5kaWNhdG9yLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVUbyhwb3NpdGlvbilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0SXRlbShwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbcG9zaXRpb25dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2xpZGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb24gaWRcbiAgICAgKiBAcGFyYW0geyp9IHBvc2l0aW9uIFxuICAgICAqL1xuICAgIHNsaWRlVG8ocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1twb3NpdGlvbl1cbiAgICAgICAgY29uc3Qgcm90YXRpb25JdGVtcyA9IHtcbiAgICAgICAgICAgICdsZWZ0JzogbmV4dEl0ZW0ucG9zaXRpb24gPT09IDAgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW25leHRJdGVtLnBvc2l0aW9uIC0gMV0sXG4gICAgICAgICAgICAnbWlkZGxlJzogbmV4dEl0ZW0sXG4gICAgICAgICAgICAncmlnaHQnOiBuZXh0SXRlbS5wb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSA/IHRoaXMuX2l0ZW1zWzBdIDogdGhpcy5faXRlbXNbbmV4dEl0ZW0ucG9zaXRpb24gKyAxXVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JvdGF0ZShyb3RhdGlvbkl0ZW1zKVxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKG5leHRJdGVtLnBvc2l0aW9uKVxuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICAgICAgdGhpcy5jeWNsZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uQ2hhbmdlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIG5leHQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5fZ2V0QWN0aXZlSXRlbSgpXG4gICAgICAgIGxldCBuZXh0SXRlbSA9IG51bGxcblxuICAgICAgICAvLyBjaGVjayBpZiBsYXN0IGl0ZW1cbiAgICAgICAgaWYgKGFjdGl2ZUl0ZW0ucG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG5leHRJdGVtID0gdGhpcy5faXRlbXNbMF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRJdGVtID0gdGhpcy5faXRlbXNbYWN0aXZlSXRlbS5wb3NpdGlvbiArIDFdXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNsaWRlVG8obmV4dEl0ZW0ucG9zaXRpb24pXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk5leHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gaXQgd2lsbCBnbyB0byB0aGUgcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKi9cbiAgICBwcmV2KCkge1xuICAgICAgICBjb25zdCBhY3RpdmVJdGVtID0gdGhpcy5fZ2V0QWN0aXZlSXRlbSgpXG4gICAgICAgIGxldCBwcmV2SXRlbSA9IG51bGxcblxuICAgICAgICAvLyBjaGVjayBpZiBmaXJzdCBpdGVtXG4gICAgICAgIGlmIChhY3RpdmVJdGVtLnBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IHRoaXMuX2l0ZW1zW2FjdGl2ZUl0ZW0ucG9zaXRpb24gLSAxXVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zbGlkZVRvKHByZXZJdGVtLnBvc2l0aW9uKVxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25QcmV2KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBhcHBsaWVzIHRoZSB0cmFuc2Zvcm0gY2xhc3NlcyBiYXNlZCBvbiB0aGUgbGVmdCwgbWlkZGxlLCBhbmQgcmlnaHQgcm90YXRpb24gY2Fyb3VzZWwgaXRlbXNcbiAgICAgKiBAcGFyYW0geyp9IHJvdGF0aW9uSXRlbXMgXG4gICAgICovXG4gICAgX3JvdGF0ZShyb3RhdGlvbkl0ZW1zKSB7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIHRoaXMuX2l0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBsZWZ0IGl0ZW0gKHByZXZpb3VzbHkgYWN0aXZlKVxuICAgICAgICByb3RhdGlvbkl0ZW1zLmxlZnQuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicsICd6LTIwJylcbiAgICAgICAgcm90YXRpb25JdGVtcy5sZWZ0LmVsLmNsYXNzTGlzdC5hZGQoJy10cmFuc2xhdGUteC1mdWxsJywgJ3otMTAnKVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBhY3RpdmUgaXRlbVxuICAgICAgICByb3RhdGlvbkl0ZW1zLm1pZGRsZS5lbC5jbGFzc0xpc3QucmVtb3ZlKCctdHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LTAnLCAnaGlkZGVuJywgJ3otMTAnKVxuICAgICAgICByb3RhdGlvbkl0ZW1zLm1pZGRsZS5lbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2xhdGUteC0wJywgJ3otMjAnKVxuXG4gICAgICAgIC8vIHJpZ2h0IGl0ZW0gKHVwY29taW5nIGFjdGl2ZSlcbiAgICAgICAgcm90YXRpb25JdGVtcy5yaWdodC5lbC5jbGFzc0xpc3QucmVtb3ZlKCctdHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LTAnLCAnaGlkZGVuJywgJ3otMjAnKVxuICAgICAgICByb3RhdGlvbkl0ZW1zLnJpZ2h0LmVsLmNsYXNzTGlzdC5hZGQoJ3RyYW5zbGF0ZS14LWZ1bGwnLCAnei0xMCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGFuIGludGVydmFsIHRvIGN5Y2xlIHRocm91Z2ggdGhlIGNhcm91c2VsIGl0ZW1zXG4gICAgICovXG4gICAgY3ljbGUoKSB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH0sIHRoaXMuX29wdGlvbnMuaW50ZXJ2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjeWNsaW5nIGludGVydmFsXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtXG4gICAgICovXG4gICAgX2dldEFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gYW5kIGRhdGEgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHsqfSBwb3NpdGlvbiBcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlSXRlbShwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gdGhpcy5faXRlbXNbcG9zaXRpb25dXG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBpbmRpY2F0b3JzIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5faW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnMubWFwKGluZGljYXRvciA9PiB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3IuZWwuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9vcHRpb25zLmluZGljYXRvcnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmVsLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9vcHRpb25zLmluZGljYXRvcnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzW3Bvc2l0aW9uXS5lbC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxud2luZG93LkNhcm91c2VsID0gQ2Fyb3VzZWw7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWxdJykuZm9yRWFjaChjYXJvdXNlbEVsID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBjYXJvdXNlbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXJvdXNlbC1pbnRlcnZhbCcpXG4gICAgICAgIGNvbnN0IHNsaWRlID0gY2Fyb3VzZWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwnKSA9PT0gJ3NsaWRlJyA/IHRydWUgOiBmYWxzZVxuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW11cbiAgICAgICAgbGV0IGRlZmF1bHRQb3NpdGlvbiA9IDBcbiAgICAgICAgaWYgKGNhcm91c2VsRWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWwtaXRlbV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFsuLi5jYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJyldLm1hcCgoY2Fyb3VzZWxJdGVtRWwsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZWw6IGNhcm91c2VsSXRlbUVsXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGlmIChjYXJvdXNlbEl0ZW1FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwtaXRlbScpID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UG9zaXRpb24gPSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmRpY2F0b3JzID0gW107XG4gICAgICAgIGlmIChjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLXNsaWRlLXRvXScpLmxlbmd0aCkge1xuICAgICAgICAgICAgWy4uLmNhcm91c2VsRWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWwtc2xpZGUtdG9dJyldLm1hcCgoaW5kaWNhdG9yRWwpID0+IHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5kaWNhdG9yRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLXNsaWRlLXRvJyksXG4gICAgICAgICAgICAgICAgICAgIGVsOiBpbmRpY2F0b3JFbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fyb3VzZWwgPSBuZXcgQ2Fyb3VzZWwoaXRlbXMsIHtcbiAgICAgICAgICAgIGRlZmF1bHRQb3NpdGlvbjogZGVmYXVsdFBvc2l0aW9uLFxuICAgICAgICAgICAgaW5kaWNhdG9yczoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBpbmRpY2F0b3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsID8gaW50ZXJ2YWwgOiBEZWZhdWx0LmludGVydmFsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgICAgICBjYXJvdXNlbC5jeWNsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvbnRyb2xzXG4gICAgICAgIGNvbnN0IGNhcm91c2VsTmV4dEVsID0gY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1uZXh0XScpXG4gICAgICAgIGNvbnN0IGNhcm91c2VsUHJldkVsID0gY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1wcmV2XScpXG5cbiAgICAgICAgaWYgKGNhcm91c2VsTmV4dEVsKSB7XG4gICAgICAgICAgICBjYXJvdXNlbE5leHRFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYXJvdXNlbC5uZXh0KClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2Fyb3VzZWxQcmV2RWwpIHtcbiAgICAgICAgICAgIGNhcm91c2VsUHJldkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhcm91c2VsLnByZXYoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgfSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsIiwiY29uc3QgRGVmYXVsdCA9IHtcbiAgICB0cmlnZ2VyRWw6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb24tb3BhY2l0eScsXG4gICAgZHVyYXRpb246IDMwMCxcbiAgICB0aW1pbmc6ICdlYXNlLW91dCcsXG4gICAgb25IaWRlOiAoKSA9PiB7IH1cbn1cblxuY2xhc3MgRGlzbWlzcyB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0RWwgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbFxuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSBvcHRpb25zID8gb3B0aW9ucy50cmlnZ2VyRWwgOiBEZWZhdWx0LnRyaWdnZXJFbFxuICAgICAgICB0aGlzLl9vcHRpb25zID0geyAuLi5EZWZhdWx0LCAuLi5vcHRpb25zIH1cbiAgICAgICAgdGhpcy5faW5pdCgpXG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQodGhpcy5fb3B0aW9ucy50cmFuc2l0aW9uLCBgZHVyYXRpb24tJHt0aGlzLl9vcHRpb25zLmR1cmF0aW9ufWAsIHRoaXMuX29wdGlvbnMudGltaW5nLCAnb3BhY2l0eS0wJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICB9LCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKVxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMuX3RhcmdldEVsKVxuICAgIH1cbn1cblxud2luZG93LkRpc21pc3MgPSBEaXNtaXNzO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRpc21pc3MtdGFyZ2V0XScpLmZvckVhY2godHJpZ2dlckVsID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzbWlzcy10YXJnZXQnKSlcblxuICAgICAgICBuZXcgRGlzbWlzcyh0YXJnZXRFbCwge1xuICAgICAgICAgICAgdHJpZ2dlckVsXG4gICAgICAgIH0pXG4gICAgfSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IERpc21pc3MiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBpbmNsdWRlU2NhbGUpIHtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDsgLy8gRG8gbm90IGF0dGVtcHQgdG8gZGl2aWRlIGJ5IDAsIG90aGVyd2lzZSB3ZSBnZXQgYEluZmluaXR5YCBhcyBzY2FsZVxuICAgIC8vIEZhbGxiYWNrIHRvIDEgaW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgYDBgXG5cbiAgICBpZiAob2Zmc2V0V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIG9mZnNldFdpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEhlaWdodCA+IDApIHtcbiAgICAgIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIG9mZnNldEhlaWdodCB8fCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggLyBzY2FsZVgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHNjYWxlWSxcbiAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGVZLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC8gc2NhbGVYLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLyBzY2FsZVksXG4gICAgbGVmdDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHg6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB5OiByZWN0LnRvcCAvIHNjYWxlWVxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDsgLy8gTkI6IFRoaXMgaXNuJ3Qgc3VwcG9ydGVkIG9uIGlPUyA8PSAxMi4gSWYgdGhlIGtleWJvYXJkIGlzIG9wZW4sIHRoZSBwb3BwZXJcbiAgLy8gY2FuIGJlIG9ic2N1cmVkIHVuZGVybmVhdGggaXQuXG4gIC8vIEFsc28sIGBodG1sLmNsaWVudEhlaWdodGAgYWRkcyB0aGUgYm90dG9tIGJhciBoZWlnaHQgaW4gU2FmYXJpIGlPUywgZXZlblxuICAvLyBpZiBpdCBpc24ndCBvcGVuLCBzbyBpZiB0aGlzIGlzbid0IGF2YWlsYWJsZSwgdGhlIHBvcHBlciB3aWxsIGJlIGRldGVjdGVkXG4gIC8vIHRvIG92ZXJmbG93IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiB0b28gZWFybHkuXG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7IC8vIFVzZXMgTGF5b3V0IFZpZXdwb3J0IChsaWtlIENocm9tZTsgU2FmYXJpIGRvZXMgbm90IGN1cnJlbnRseSlcbiAgICAvLyBJbiBDaHJvbWUsIGl0IHJldHVybnMgYSB2YWx1ZSB2ZXJ5IGNsb3NlIHRvIDAgKCsvLSkgYnV0IGNvbnRhaW5zIHJvdW5kaW5nXG4gICAgLy8gZXJyb3JzIGR1ZSB0byBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHByZWNpc2lvbi5cbiAgICAvLyBTYWZhcmkgcmV0dXJucyBhIG51bWJlciA8PSAwLCB1c3VhbGx5IDwgLTEgd2hlbiBwaW5jaC16b29tZWRcbiAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmYWlscyBpbiBtb2JpbGUgZW11bGF0aW9uIG1vZGUgaW4gQ2hyb21lLlxuICAgIC8vIE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdmlzdWFsVmlld3BvcnQuc2NhbGUgLSB2aXN1YWxWaWV3cG9ydC53aWR0aCkgPFxuICAgIC8vIDAuMDAxXG4gICAgLy8gRmFsbGJhY2sgaGVyZTogXCJOb3QgU2FmYXJpXCIgdXNlckFnZW50XG5cbiAgICBpZiAoIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIHRyaWdnZXJUeXBlOiAnY2xpY2snLFxuICAgIG9uU2hvdzogKCkgPT4geyB9LFxuICAgIG9uSGlkZTogKCkgPT4geyB9XG59XG5cbmNsYXNzIERyb3Bkb3duIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRFbGVtZW50ID0gbnVsbCwgdHJpZ2dlckVsZW1lbnQgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbGVtZW50XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbGVtZW50XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7IC4uLkRlZmF1bHQsIC4uLm9wdGlvbnMgfVxuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVBvcHBlckluc3RhY2UoKVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2VcbiAgICAgICAgdGhpcy5faW5pdCgpXG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZVBvcHBlckluc3RhY2UoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3BwZXIodGhpcy5fdHJpZ2dlckVsLCB0aGlzLl90YXJnZXRFbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIDEwXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2hhbmRsZUNsaWNrT3V0c2lkZShldiwgdGFyZ2V0RWwpIHtcbiAgICAgICAgY29uc3QgY2xpY2tlZEVsID0gZXYudGFyZ2V0XG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmICF0YXJnZXRFbC5jb250YWlucyhjbGlja2VkRWwpICYmICF0aGlzLl90cmlnZ2VyRWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJiB0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbGlja091dHNpZGUsIHRydWUpXG4gICAgfVxuXG4gICAgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbGlja091dHNpZGUsIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnYmxvY2snKVxuXG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyA9PiAoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMubW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXYpID0+IHsgdGhpcy5faGFuZGxlQ2xpY2tPdXRzaWRlKGV2LCB0aGlzLl90YXJnZXRFbCkgfSwgdHJ1ZSlcblxuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3coKVxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Jsb2NrJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcblxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zID0+ICh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5tb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpXG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUoKVxuICAgIH1cbn1cblxud2luZG93LkRyb3Bkb3duID0gRHJvcGRvd247XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHJvcGRvd24tdG9nZ2xlXScpLmZvckVhY2godHJpZ2dlckVsID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXRvZ2dsZScpKVxuICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSB0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXBsYWNlbWVudCcpXG5cbiAgICAgICAgbmV3IERyb3Bkb3duKHRhcmdldEVsLCB0cmlnZ2VyRWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50ID8gcGxhY2VtZW50IDogRGVmYXVsdC5wbGFjZW1lbnRcbiAgICAgICAgfSlcbiAgICB9KVxufSlcblxuZXhwb3J0IGRlZmF1bHQgRHJvcGRvd24iLCJjb25zdCBEZWZhdWx0ID0ge1xuICAgIHBsYWNlbWVudDogJ2NlbnRlcicsXG4gICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAgYmctb3BhY2l0eS01MCBkYXJrOmJnLW9wYWNpdHktODAgZml4ZWQgaW5zZXQtMCB6LTQwJyxcbiAgICBvbkhpZGU6ICgpID0+IHt9LFxuICAgIG9uU2hvdzogKCkgPT4ge30sXG4gICAgb25Ub2dnbGU6ICgpID0+IHt9XG59XG5jbGFzcyBNb2RhbCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0RWwgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbFxuICAgICAgICB0aGlzLl9vcHRpb25zID0geyAuLi5EZWZhdWx0LCAuLi5vcHRpb25zIH1cbiAgICAgICAgdGhpcy5faXNIaWRkZW4gPSB0cnVlXG4gICAgICAgIHRoaXMuX2luaXQoKVxuICAgIH1cblxuICAgIF9pbml0KCkge1xuICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKCkubWFwKGMgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIF9jcmVhdGVCYWNrZHJvcCgpIHtcbiAgICAgICAgaWYodGhpcy5faXNIaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tkcm9wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJhY2tkcm9wRWwuc2V0QXR0cmlidXRlKCdtb2RhbC1iYWNrZHJvcCcsICcnKTtcbiAgICAgICAgICAgIGJhY2tkcm9wRWwuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9vcHRpb25zLmJhY2tkcm9wQ2xhc3Nlcy5zcGxpdChcIiBcIikpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZChiYWNrZHJvcEVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kZXN0cm95QmFja2Ryb3BFbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0hpZGRlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW21vZGFsLWJhY2tkcm9wXScpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFBsYWNlbWVudENsYXNzZXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgLy8gdG9wXG4gICAgICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1zdGFydCcsICdpdGVtcy1zdGFydCddXG4gICAgICAgICAgICBjYXNlICd0b3AtY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1zdGFydCddXG4gICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktZW5kJywgJ2l0ZW1zLXN0YXJ0J11cblxuICAgICAgICAgICAgLy8gY2VudGVyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXItbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1zdGFydCcsICdpdGVtcy1jZW50ZXInXVxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1jZW50ZXInXVxuICAgICAgICAgICAgY2FzZSAnY2VudGVyLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWVuZCcsICdpdGVtcy1jZW50ZXInXVxuXG4gICAgICAgICAgICAvLyBib3R0b21cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LXN0YXJ0JywgJ2l0ZW1zLWVuZCddXG4gICAgICAgICAgICBjYXNlICdib3R0b20tY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1lbmQnXVxuICAgICAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWVuZCcsICdpdGVtcy1lbmQnXVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktY2VudGVyJywgJ2l0ZW1zLWNlbnRlciddXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0hpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKClcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdmbGV4JylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKVxuICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tkcm9wKClcbiAgICAgICAgdGhpcy5faXNIaWRkZW4gPSBmYWxzZVxuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KClcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdmbGV4JylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJylcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdyb2xlJylcbiAgICAgICAgdGhpcy5fZGVzdHJveUJhY2tkcm9wRWwoKVxuICAgICAgICB0aGlzLl9pc0hpZGRlbiA9IHRydWVcblxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSgpXG4gICAgfVxuXG59XG5cbndpbmRvdy5Nb2RhbCA9IE1vZGFsO1xuXG5jb25zdCBnZXRNb2RhbEluc3RhbmNlID0gKGlkLCBpbnN0YW5jZXMpID0+IHtcbiAgICBpZiAoaW5zdGFuY2VzLnNvbWUobW9kYWxJbnN0YW5jZSA9PiBtb2RhbEluc3RhbmNlLmlkID09PSBpZCkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcy5maW5kKG1vZGFsSW5zdGFuY2UgPT4gbW9kYWxJbnN0YW5jZS5pZCA9PT0gaWQpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGxldCBtb2RhbEluc3RhbmNlcyA9IFtdXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9kYWwtdG9nZ2xlXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBjb25zdCBtb2RhbElkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXRvZ2dsZScpO1xuICAgICAgICBjb25zdCBtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IG1vZGFsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXBsYWNlbWVudCcpXG5cbiAgICAgICAgaWYgKG1vZGFsRWwpIHtcbiAgICAgICAgICAgIGlmICghbW9kYWxFbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgJiYgIW1vZGFsRWwuaGFzQXR0cmlidXRlKCdhcmlhLW1vZGFsJykpIHtcbiAgICAgICAgICAgICAgICBtb2RhbEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1vZGFsID0gbnVsbFxuICAgICAgICBpZiAoZ2V0TW9kYWxJbnN0YW5jZShtb2RhbElkLCBtb2RhbEluc3RhbmNlcykpIHtcbiAgICAgICAgICAgIG1vZGFsID0gZ2V0TW9kYWxJbnN0YW5jZShtb2RhbElkLCBtb2RhbEluc3RhbmNlcylcbiAgICAgICAgICAgIG1vZGFsID0gbW9kYWwub2JqZWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RhbCA9IG5ldyBNb2RhbChtb2RhbEVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG1vZGFsSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBtb2RhbElkLFxuICAgICAgICAgICAgICAgIG9iamVjdDogbW9kYWxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIG1vZGFsLnRvZ2dsZSgpXG4gICAgICAgIH0pXG4gICAgfSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsIiwiY29uc3QgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0VGFiSWQ6IG51bGwsXG4gICAgYWN0aXZlQ2xhc3NlczogJ3RleHQtYmx1ZS02MDAgaG92ZXI6dGV4dC1ibHVlLTYwMCBkYXJrOnRleHQtYmx1ZS01MDAgZGFyazpob3Zlcjp0ZXh0LWJsdWUtNDAwIGJvcmRlci1ibHVlLTYwMCBkYXJrOmJvcmRlci1ibHVlLTUwMCcsXG4gICAgaW5hY3RpdmVDbGFzc2VzOiAndGV4dC1ncmF5LTUwMCBob3Zlcjp0ZXh0LWdyYXktNjAwIGRhcms6dGV4dC1ncmF5LTQwMCBib3JkZXItZ3JheS0xMDAgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNzAwIGRhcms6aG92ZXI6dGV4dC1ncmF5LTMwMCcsXG4gICAgb25TaG93OiAoKSA9PiB7IH1cbn1cblxuY2xhc3MgVGFicyB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXNcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFiID0gb3B0aW9ucyA/IHRoaXMuZ2V0VGFiKG9wdGlvbnMuZGVmYXVsdFRhYklkKSA6IG51bGxcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsgLi4uRGVmYXVsdCwgLi4ub3B0aW9ucyB9XG4gICAgICAgIHRoaXMuX2luaXQoKVxuICAgIH1cblxuICAgIF9pbml0KCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGZpcnN0IHRhYiBhcyBhY3RpdmUgaWYgbm90IHNldCBieSBleHBsaWNpdGx5XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZVRhYih0aGlzLl9pdGVtc1swXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yY2Ugc2hvdyB0aGUgZmlyc3QgZGVmYXVsdCB0YWJcbiAgICAgICAgICAgIHRoaXMuc2hvdyh0aGlzLl9hY3RpdmVUYWIuaWQsIHRydWUpXG5cbiAgICAgICAgICAgIC8vIHNob3cgdGFiIGNvbnRlbnQgYmFzZWQgb24gY2xpY2tcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLm1hcCh0YWIgPT4ge1xuICAgICAgICAgICAgICAgIHRhYi50cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdyh0YWIuaWQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBY3RpdmVUYWIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUYWJcbiAgICB9XG5cbiAgICBfc2V0QWN0aXZlVGFiKHRhYikge1xuICAgICAgICB0aGlzLl9hY3RpdmVUYWIgPSB0YWJcbiAgICB9XG5cbiAgICBnZXRUYWIoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbHRlcih0ID0+IHQuaWQgPT09IGlkKVswXVxuICAgIH1cblxuICAgIHNob3coaWQsIGZvcmNlU2hvdyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRhYiA9IHRoaXMuZ2V0VGFiKGlkKVxuXG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIGFscmVhZHkgYWN0aXZlXG4gICAgICAgIGlmICh0YWIgPT09IHRoaXMuX2FjdGl2ZVRhYiAmJiAhZm9yY2VTaG93KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhpZGUgb3RoZXIgdGFic1xuICAgICAgICB0aGlzLl9pdGVtcy5tYXAodCA9PiB7XG4gICAgICAgICAgICBpZiAodCAhPT0gdGFiKSB7XG4gICAgICAgICAgICAgICAgdC50cmlnZ2VyRWwuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICB0LnRyaWdnZXJFbC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgdC50YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgICAgICAgICAgICAgIHQudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHNob3cgYWN0aXZlIHRhYlxuICAgICAgICB0YWIudHJpZ2dlckVsLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fb3B0aW9ucy5hY3RpdmVDbGFzc2VzLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIHRhYi50cmlnZ2VyRWwuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdChcIiBcIikpO1xuICAgICAgICB0YWIudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpXG4gICAgICAgIHRhYi50YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxuXG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZVRhYih0YWIpXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3coKVxuICAgIH1cblxufVxuXG53aW5kb3cuVGFicyA9IFRhYnM7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFicy10b2dnbGVdJykuZm9yRWFjaCh0cmlnZ2VyRWwgPT4ge1xuXG4gICAgICAgIGNvbnN0IHRhYkVsZW1lbnRzID0gW11cbiAgICAgICAgbGV0IGRlZmF1bHRUYWJJZCA9IG51bGxcbiAgICAgICAgdHJpZ2dlckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidGFiXCJdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcpID09PSAndHJ1ZSdcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IHtcbiAgICAgICAgICAgICAgICBpZDogZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMtdGFyZ2V0JyksXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVsOiBlbCxcbiAgICAgICAgICAgICAgICB0YXJnZXRFbDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFicy10YXJnZXQnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYkVsZW1lbnRzLnB1c2godGFiKVxuXG4gICAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFiSWQgPSB0YWIuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgbmV3IFRhYnModGFiRWxlbWVudHMsIHtcbiAgICAgICAgICAgIGRlZmF1bHRUYWJJZDogZGVmYXVsdFRhYklkXG4gICAgICAgIH0pXG4gICAgfSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFRhYnMiLCJpbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICBvblNob3c6ICgpID0+IHsgfSxcbiAgICBvbkhpZGU6ICgpID0+IHsgfVxufVxuXG5jbGFzcyBUb29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRFbCA9IG51bGwsIHRyaWdnZXJFbCA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsXG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbFxuICAgICAgICB0aGlzLl9vcHRpb25zID0geyAuLi5EZWZhdWx0LCAuLi5vcHRpb25zIH1cbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQb3BwZXJJbnN0YWNlKClcbiAgICAgICAgdGhpcy5faW5pdCgpXG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJFdmVudHMgPSB0aGlzLl9nZXRUcmlnZ2VyRXZlbnRzKClcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZXYgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlUG9wcGVySW5zdGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcHBlcih0aGlzLl90cmlnZ2VyRWwsIHRoaXMuX3RhcmdldEVsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRUcmlnZ2VyRXZlbnRzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnZm9jdXNvdXQnLCAnYmx1ciddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKVxuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTEwMCcsICd2aXNpYmxlJylcblxuICAgICAgICAvLyBFbmFibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMgPT4gKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLm1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3coKVxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMTAwJywgJ3Zpc2libGUnKVxuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTAnLCAnaW52aXNpYmxlJylcblxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zID0+ICh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5tb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKClcbiAgICB9XG59XG5cbndpbmRvdy5Ub29sdGlwID0gVG9vbHRpcDtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b29sdGlwLXRhcmdldF0nKS5mb3JFYWNoKHRyaWdnZXJFbCA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRhcmdldCcpKVxuICAgICAgICBjb25zdCB0cmlnZ2VyVHlwZSA9IHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcC10cmlnZ2VyJyk7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcC1wbGFjZW1lbnQnKTtcblxuICAgICAgICBuZXcgVG9vbHRpcCh0YXJnZXRFbCwgdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCA/IHBsYWNlbWVudCA6IERlZmF1bHQucGxhY2VtZW50LFxuICAgICAgICAgICAgdHJpZ2dlclR5cGU6IHRyaWdnZXJUeXBlID8gdHJpZ2dlclR5cGUgOiBEZWZhdWx0LnRyaWdnZXJUeXBlXG4gICAgICAgIH0pXG4gICAgfSlcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXAiLCJpbXBvcnQgJy4vZmxvd2JpdGUuY3NzJztcblxuLy8gY29yZSBjb21wb25lbnRzXG5pbXBvcnQgQWNjb3JkaW9uIGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24nXG5pbXBvcnQgQ29sbGFwc2UgZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlJ1xuaW1wb3J0IENhcm91c2VsIGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbCdcbmltcG9ydCBEaXNtaXNzIGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzJ1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4vY29tcG9uZW50cy9kcm9wZG93bidcbmltcG9ydCBNb2RhbCBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnXG5pbXBvcnQgVGFicyBmcm9tICcuL2NvbXBvbmVudHMvdGFicydcbmltcG9ydCBUb29sdGlwIGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgQWNjb3JkaW9uLFxuICAgIENvbGxhcHNlLFxuICAgIENhcm91c2VsLFxuICAgIERpc21pc3MsXG4gICAgRHJvcGRvd24sXG4gICAgTW9kYWwsXG4gICAgVGFicyxcbiAgICBUb29sdGlwLFxufSIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIEZvcm1hdHMgaG91cnMgZnVuY3Rpb25cclxuLy8gT3BlbiDCtyBDbG9zZXMgYXQgNXBtXHJcbi8vIENsb3NlZCDCtyBPcGVuIGF0IDZhbVxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T3Blbk5vd1N0cmluZyhob3Vyc0RhdGEsIHV0Y09mZnNldCkge1xyXG4gIGNvbnN0IG5vdyA9IGdldFlleHRUaW1lV2l0aFV0Y09mZnNldCh1dGNPZmZzZXQpO1xyXG5cclxuICBjb25zdCB0b21vcnJvdyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyA2MCAqIDYwICogMjQgKiAxMDAwKTtcclxuICBjb25zdCB5ZXN0ZXJkYXkgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gNjAgKiA2MCAqIDI0ICogMTAwMCk7XHJcbiAgY29uc3Qgbm93VGltZU51bWJlciA9IG5vdy5nZXRIb3VycygpICsgbm93LmdldE1pbnV0ZXMoKSAvIDYwO1xyXG5cclxuICBjb25zdCBpbnRlcnZhbHNUb2RheSA9IGdldEludGVydmFsT25EYXRlKG5vdywgaG91cnNEYXRhKTtcclxuICBjb25zdCBpbnRlcnZhbHNUb21vcnJvdyA9IGdldEludGVydmFsT25EYXRlKHRvbW9ycm93LCBob3Vyc0RhdGEpO1xyXG4gIGNvbnN0IGludGVydmFsc1llc3RlcmRheSA9IGdldEludGVydmFsT25EYXRlKHllc3RlcmRheSwgaG91cnNEYXRhKTtcclxuICBsZXQgb3BlblJpZ2h0Tm93ID0gZmFsc2U7XHJcbiAgbGV0IGN1cnJlbnRJbnRlcnZhbCA9IG51bGw7XHJcbiAgbGV0IG5leHRJbnRlcnZhbCA9IG51bGw7XHJcblxyXG4gIGlmIChpbnRlcnZhbHNZZXN0ZXJkYXkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJ2YWxzWWVzdGVyZGF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGludGVydmFsID0gaW50ZXJ2YWxzWWVzdGVyZGF5W2ldO1xyXG4gICAgICBjb25zdCBzdGFydEludGVydmFsTnVtYmVyID0gdGltZVN0cmluZ1RvTnVtYmVyKGludGVydmFsLnN0YXJ0KTtcclxuICAgICAgY29uc3QgZW5kSW50ZXJ2YWxOdW1iZXIgPSB0aW1lU3RyaW5nVG9OdW1iZXIoaW50ZXJ2YWwuZW5kKTtcclxuXHJcbiAgICAgIC8vIElmIGVuZCBvdmVyZmxvd3MgdG8gdGhlIG5leHQgZGF5IChpLmUuIHRvZGF5KS5cclxuICAgICAgaWYgKGVuZEludGVydmFsTnVtYmVyIDwgc3RhcnRJbnRlcnZhbE51bWJlcikge1xyXG4gICAgICAgIGlmIChub3dUaW1lTnVtYmVyIDwgZW5kSW50ZXJ2YWxOdW1iZXIpIHtcclxuICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IGludGVydmFsO1xyXG4gICAgICAgICAgb3BlblJpZ2h0Tm93ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFzc3VtZXMgbm8gb3ZlcmxhcHBpbmcgaW50ZXJ2YWxzXHJcbiAgaWYgKGludGVydmFsc1RvZGF5KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVydmFsc1RvZGF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGludGVydmFsID0gaW50ZXJ2YWxzVG9kYXlbaV07XHJcbiAgICAgIGNvbnN0IHN0YXJ0SW50ZXJ2YWxOdW1iZXIgPSB0aW1lU3RyaW5nVG9OdW1iZXIoaW50ZXJ2YWwuc3RhcnQpO1xyXG4gICAgICBjb25zdCBlbmRJbnRlcnZhbE51bWJlciA9IHRpbWVTdHJpbmdUb051bWJlcihpbnRlcnZhbC5lbmQpO1xyXG5cclxuICAgICAgLy8gSWYgY3VycmVudCB0aW1lIGRvZXNuJ3QgYmVsb25nIHRvIG9uZSBvZiB5ZXN0ZXJkYXlzIGludGVydmFsLlxyXG4gICAgICBpZiAoY3VycmVudEludGVydmFsID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZW5kSW50ZXJ2YWxOdW1iZXIgPCBzdGFydEludGVydmFsTnVtYmVyKSB7XHJcbiAgICAgICAgICBpZiAobm93VGltZU51bWJlciA+PSBzdGFydEludGVydmFsTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IGludGVydmFsO1xyXG4gICAgICAgICAgICBvcGVuUmlnaHROb3cgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBub3dUaW1lTnVtYmVyID49IHN0YXJ0SW50ZXJ2YWxOdW1iZXIgJiZcclxuICAgICAgICAgIG5vd1RpbWVOdW1iZXIgPCBlbmRJbnRlcnZhbE51bWJlclxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY3VycmVudEludGVydmFsID0gaW50ZXJ2YWw7XHJcbiAgICAgICAgICBvcGVuUmlnaHROb3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5leHRJbnRlcnZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW50ZXJ2YWxOdW1iZXIgPiBub3dUaW1lTnVtYmVyKSB7XHJcbiAgICAgICAgICBuZXh0SW50ZXJ2YWwgPSBpbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgc3RhcnRJbnRlcnZhbE51bWJlciA+IG5vd1RpbWVOdW1iZXIgJiZcclxuICAgICAgICAgIHN0YXJ0SW50ZXJ2YWxOdW1iZXIgPCB0aW1lU3RyaW5nVG9OdW1iZXIobmV4dEludGVydmFsLnN0YXJ0KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgbmV4dEludGVydmFsID0gaW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgbmV4dElzVG9tb3Jyb3cgPSBmYWxzZTtcclxuXHJcbiAgLy8gSWYgbm8gbW9yZSBpbnRlcnZhbHMgaW4gdGhlIGRheVxyXG4gIGlmIChuZXh0SW50ZXJ2YWwgPT0gbnVsbCkge1xyXG4gICAgaWYgKGludGVydmFsc1RvbW9ycm93KSB7XHJcbiAgICAgIGlmIChpbnRlcnZhbHNUb21vcnJvdy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbmV4dEludGVydmFsID0gaW50ZXJ2YWxzVG9tb3Jyb3dbMF07XHJcbiAgICAgICAgbmV4dElzVG9tb3Jyb3cgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgaG91cnNTdHJpbmcgPSBcIlwiO1xyXG5cclxuICBpZiAobmV4dEludGVydmFsKSB7XHJcbiAgICBpZiAob3BlblJpZ2h0Tm93KSB7XHJcbiAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBhIDI0LWhvdXIgaW50ZXJ2YWwsIHRoZW4gY2hlY2sgZm9yIG9wZW4gcGFzdCBtaWRuaWdodFxyXG4gICAgICBpZiAoY3VycmVudEludGVydmFsLnN0YXJ0ID09IFwiMDA6MDBcIiAmJiBjdXJyZW50SW50ZXJ2YWwuZW5kID09IFwiMjM6NTlcIikge1xyXG4gICAgICAgIGhvdXJzU3RyaW5nICs9IFwiPHN0cm9uZz5PcGVuIDI0IGhvdXJzPC9zdHJvbmc+XCI7XHJcbiAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgbmV4dEludGVydmFsLnN0YXJ0ID09IFwiMDA6MDBcIiAmJlxyXG4gICAgICAgIGN1cnJlbnRJbnRlcnZhbC5lbmQgPT0gXCIyMzo1OVwiXHJcbiAgICAgICkge1xyXG4gICAgICAgIGhvdXJzU3RyaW5nICs9XHJcbiAgICAgICAgICBcIjxzdHJvbmc+T3Blbjwvc3Ryb25nPiDCtyBDbG9zZXMgYXQgW2Nsb3NpbmdUaW1lXSB0b21vcnJvd1wiO1xyXG4gICAgICAgIGhvdXJzU3RyaW5nID0gaG91cnNTdHJpbmcucmVwbGFjZShcclxuICAgICAgICAgIFwiW2Nsb3NpbmdUaW1lXVwiLFxyXG4gICAgICAgICAgLy8gZm9ybWF0VGltZShjdXJyZW50SW50ZXJ2YWwuZW5kKVxyXG4gICAgICAgICAgY3VycmVudEludGVydmFsLmVuZFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaG91cnNTdHJpbmcgKz0gXCI8c3Ryb25nPk9wZW48L3N0cm9uZz4gwrcgQ2xvc2VzIGF0IFtjbG9zaW5nVGltZV1cIjtcclxuICAgICAgICBob3Vyc1N0cmluZyA9IGhvdXJzU3RyaW5nLnJlcGxhY2UoXHJcbiAgICAgICAgICBcIltjbG9zaW5nVGltZV1cIixcclxuICAgICAgICAgIC8vIGZvcm1hdFRpbWUoY3VycmVudEludGVydmFsLmVuZClcclxuICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbC5lbmRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobmV4dElzVG9tb3Jyb3cpIHtcclxuICAgICAgICBob3Vyc1N0cmluZyArPVxyXG4gICAgICAgICAgXCI8c3Ryb25nPkNsb3NlZDwvc3Ryb25nPiDCtyBPcGVucyBhdCBbb3BlbmluZ1RpbWVdIHRvbW9ycm93XCI7XHJcbiAgICAgICAgaG91cnNTdHJpbmcgPSBob3Vyc1N0cmluZy5yZXBsYWNlKFxyXG4gICAgICAgICAgXCJbb3BlbmluZ1RpbWVdXCIsXHJcbiAgICAgICAgICAvLyBmb3JtYXRUaW1lKG5leHRJbnRlcnZhbC5zdGFydClcclxuICAgICAgICAgIG5leHRJbnRlcnZhbC5zdGFydFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaG91cnNTdHJpbmcgKz0gXCI8c3Ryb25nPkNsb3NlZDwvc3Ryb25nPiDCtyBPcGVucyBhdCBbb3BlbmluZ1RpbWVdXCI7XHJcbiAgICAgICAgaG91cnNTdHJpbmcgPSBob3Vyc1N0cmluZy5yZXBsYWNlKFxyXG4gICAgICAgICAgXCJbb3BlbmluZ1RpbWVdXCIsXHJcbiAgICAgICAgICAvLyBmb3JtYXRUaW1lKG5leHRJbnRlcnZhbC5zdGFydClcclxuICAgICAgICAgIG5leHRJbnRlcnZhbC5zdGFydFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBob3Vyc1N0cmluZztcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VGltZSh0aW1lKSB7XHJcbiAgY29uc3QgdGVtcERhdGUgPSBuZXcgRGF0ZShcIkphbnVhcnkgMSwgMjAyMCBcIiArIHRpbWUpO1xyXG4gIGNvbnN0IGxvY2FsZVN0cmluZyA9IFwiZW4tVVNcIjtcclxuICByZXR1cm4gdGVtcERhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKGxvY2FsZVN0cmluZy5yZXBsYWNlKFwiX1wiLCBcIi1cIiksIHtcclxuICAgIGhvdXI6IFwibnVtZXJpY1wiLFxyXG4gICAgbWludXRlOiBcIm51bWVyaWNcIixcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGltZVN0cmluZ1RvTnVtYmVyKHRpbWVTdHJpbmc6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgY29uc3QgcGFydHMgPSB0aW1lU3RyaW5nLnNwbGl0KFwiOlwiKTtcclxuICBjb25zdCBob3VycyA9IHBhcnNlSW50KHBhcnRzWzBdLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksIDEwKTtcclxuICBjb25zdCBtaW51dGVzID0gcGFyc2VJbnQocGFydHNbMV0ucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSwgMTApO1xyXG4gIHJldHVybiBob3VycyArIG1pbnV0ZXMgLyA2MDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0WWV4dFRpbWVXaXRoVXRjT2Zmc2V0KGVudGl0eVV0Y09mZnNldFNlY29uZHM6IG51bWJlcik6IERhdGUge1xyXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgbGV0IHV0Y09mZnNldCA9IDA7XHJcbiAgaWYgKGVudGl0eVV0Y09mZnNldFNlY29uZHMpIHtcclxuICAgIHV0Y09mZnNldCA9IGVudGl0eVV0Y09mZnNldFNlY29uZHMgKiAxMDAwO1xyXG4gIH1cclxuICBpZiAodXRjT2Zmc2V0ICE9PSAwKSB7XHJcbiAgICBjb25zdCBsb2NhbFV0Y09mZnNldCA9IG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKG5vdy52YWx1ZU9mKCkgKyB1dGNPZmZzZXQgKyBsb2NhbFV0Y09mZnNldCk7XHJcbiAgfVxyXG4gIHJldHVybiBub3c7XHJcbn1cclxuXHJcbi8vIFBhcnNlcyBhbiBvZmZzZXQgZm9ybWF0dGVkIGxpa2UgeysvLX17MDR9OnswMH1cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVGltZVpvbmVVdGNPZmZzZXQodGltZVN0cmluZykge1xyXG4gIGlmICghdGltZVN0cmluZykge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGNvbnN0IHBhcnRzID0gdGltZVN0cmluZy5zcGxpdChcIjpcIik7XHJcbiAgY29uc3QgaG91cnMgPSBwYXJzZUludChwYXJ0c1swXS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLCAxMCk7XHJcbiAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KHBhcnRzWzFdLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksIDEwKTtcclxuICBpZiAoaG91cnMgPCAwKSB7XHJcbiAgICByZXR1cm4gLShNYXRoLmFicyhob3VycykgKyBtaW51dGVzIC8gNjApICogNjAgKiA2MDtcclxuICB9XHJcbiAgcmV0dXJuIChob3VycyArIG1pbnV0ZXMgLyA2MCkgKiA2MCAqIDYwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbnRlcnZhbE9uRGF0ZShkYXRlLCBob3Vyc0RhdGEpIHtcclxuICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcclxuICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XHJcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHJcbiAgY29uc3QgZGF5cyA9IFtcclxuICAgIFwic3VuZGF5XCIsXHJcbiAgICBcIm1vbmRheVwiLFxyXG4gICAgXCJ0dWVzZGF5XCIsXHJcbiAgICBcIndlZG5lc2RheVwiLFxyXG4gICAgXCJ0aHVyc2RheVwiLFxyXG4gICAgXCJmcmlkYXlcIixcclxuICAgIFwic2F0dXJkYXlcIixcclxuICBdO1xyXG5cclxuICBjb25zdCBkYXRlU3RyaW5nID1cclxuICAgIHllYXIgK1xyXG4gICAgXCItXCIgK1xyXG4gICAgKG1vbnRoIDwgMTAgPyBcIjBcIiArIG1vbnRoIDogbW9udGgpICtcclxuICAgIFwiLVwiICtcclxuICAgIChkYXkgPCAxMCA/IFwiMFwiICsgZGF5IDogZGF5KTtcclxuICBjb25zdCBkYXlPZldlZWtTdHJpbmcgPSBkYXlzW2RhdGUuZ2V0RGF5KCldO1xyXG5cclxuICAvLyBDaGVjayBmb3IgaG9saWRheVxyXG4gIGlmIChob3Vyc0RhdGEuaG9saWRheUhvdXJzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdXJzRGF0YS5ob2xpZGF5SG91cnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgaG9saWRheSA9IGhvdXJzRGF0YS5ob2xpZGF5SG91cnNbaV07XHJcbiAgICAgIGlmIChob2xpZGF5LmRhdGUgPT0gZGF0ZVN0cmluZykge1xyXG4gICAgICAgIGlmIChob2xpZGF5Lm9wZW5JbnRlcnZhbHMpIHtcclxuICAgICAgICAgIHJldHVybiBob2xpZGF5Lm9wZW5JbnRlcnZhbHM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob2xpZGF5LmlzQ2xvc2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gT24gaG9saWRheSBidXQgY2xvc2VkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOb3Qgb24gaG9saWRheVxyXG4gIGlmIChob3Vyc0RhdGFbZGF5T2ZXZWVrU3RyaW5nXSAmJiBob3Vyc0RhdGFbZGF5T2ZXZWVrU3RyaW5nXS5vcGVuSW50ZXJ2YWxzKSB7XHJcbiAgICByZXR1cm4gaG91cnNEYXRhW2RheU9mV2Vla1N0cmluZ10ub3BlbkludGVydmFscztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9hZGRyZXNzLnN2Z1wiOiBcIi4vc3JjL2ltYWdlcy9hZGRyZXNzLnN2Z1wiLFxuXHRcIi4vYmFubmVyLndlYnBcIjogXCIuL3NyYy9pbWFnZXMvYmFubmVyLndlYnBcIixcblx0XCIuL2xlZnQtYXJyb3cuc3ZnXCI6IFwiLi9zcmMvaW1hZ2VzL2xlZnQtYXJyb3cuc3ZnXCIsXG5cdFwiLi9sdXh1cnlzdG9yZS5qcGVnXCI6IFwiLi9zcmMvaW1hZ2VzL2x1eHVyeXN0b3JlLmpwZWdcIixcblx0XCIuL3Bob25lLnN2Z1wiOiBcIi4vc3JjL2ltYWdlcy9waG9uZS5zdmdcIixcblx0XCIuL3JpZ2h0LWFycm93LnN2Z1wiOiBcIi4vc3JjL2ltYWdlcy9yaWdodC1hcnJvdy5zdmdcIixcblx0XCIuL3NsaWRlLndlYnBcIjogXCIuL3NyYy9pbWFnZXMvc2xpZGUud2VicFwiLFxuXHRcIi4vdGltZS5zdmdcIjogXCIuL3NyYy9pbWFnZXMvdGltZS5zdmdcIixcblx0XCIuL3lleHQtZmF2aWNvbi5wbmdcIjogXCIuL3NyYy9pbWFnZXMveWV4dC1mYXZpY29uLnBuZ1wiLFxuXHRcIi4veWV4dC1sb2dvLnN2Z1wiOiBcIi4vc3JjL2ltYWdlcy95ZXh0LWxvZ28uc3ZnXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vc3JjL2ltYWdlcyBzeW5jIFxcXFwuKHBuZ3xqcGU/Z3xzdmd8d2VicCkkXCI7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJpbXBvcnQgJy4vbWFpbi5jc3MnO1xyXG5pbXBvcnQgJ2Zsb3diaXRlJztcclxuaW1wb3J0IHtcclxuICBwYXJzZVRpbWVab25lVXRjT2Zmc2V0LFxyXG4gIGZvcm1hdE9wZW5Ob3dTdHJpbmcsXHJcbiAgZm9ybWF0VGltZVxyXG59IGZyb20gXCIvc3JjL2xvY2F0b3IvdGltZVwiO1xyXG5cclxuZnVuY3Rpb24gaW1wb3J0QWxsKHIpIHtcclxuICAgIGxldCBpbWFnZXMgPSB7fTtcclxuICAgIHIua2V5cygpLm1hcCgoaXRlbSwgaW5kZXgpID0+IHsgaW1hZ2VzW2l0ZW0ucmVwbGFjZSgnLi8nLCAnJyldID0gcihpdGVtKTsgfSk7XHJcbiAgICByZXR1cm4gaW1hZ2VzO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBpbWFnZXMgPSBpbXBvcnRBbGwocmVxdWlyZS5jb250ZXh0KCcuL2ltYWdlcycsIGZhbHNlLCAvXFwuKHBuZ3xqcGU/Z3xzdmd8d2VicCkkLykpO1xyXG5cclxuICAiXSwic291cmNlUm9vdCI6IiJ9